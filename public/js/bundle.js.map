{"version":3,"file":"bundle.js","sources":["../../node_modules/tslib/tslib.es6.js","../../node_modules/graphinius/lib/core/interfaces.ts","../../node_modules/graphinius/lib/config/run_config.ts","../../node_modules/graphinius/lib/utils/Logger.ts","../../node_modules/graphinius/lib/core/compute/ComputeGraph.ts","../../node_modules/graphinius/lib/utils/CallbackUtils.ts","../../node_modules/graphinius/lib/traversal/BFS.ts","../../node_modules/graphinius/lib/traversal/DFS.ts","../../node_modules/graphinius/lib/datastructs/BinaryHeap.ts","../../node_modules/graphinius/lib/traversal/PFS.ts","../../node_modules/graphinius/lib/traversal/BellmanFord.ts","../../node_modules/graphinius/lib/traversal/Johnsons.ts","../../node_modules/graphinius/lib/core/base/BaseGraph.ts","../../node_modules/graphinius/lib/utils/StructUtils.ts","../../node_modules/graphinius/lib/core/base/BaseNode.ts","../../node_modules/graphinius/lib/core/base/BaseEdge.ts","../../node_modules/graphinius/lib/core/typed/TypedEdge.ts","../../node_modules/graphinius/lib/core/typed/TypedNode.ts","../../node_modules/graphinius/lib/core/typed/TypedGraph.ts","../../node_modules/graphinius/lib/centralities/Degree.ts","../../node_modules/graphinius/lib/centralities/Pagerank.ts","../../node_modules/graphinius/lib/utils/RemoteUtils.ts","../../node_modules/graphinius/lib/io/interfaces.ts","../../node_modules/graphinius/lib/io/common/Dupes.ts","../../node_modules/uuid/lib/rng-browser.js","../../node_modules/uuid/lib/bytesToUuid.js","../../node_modules/uuid/v1.js","../../node_modules/uuid/v4.js","../../node_modules/uuid/index.js","../../node_modules/graphinius/lib/io/input/JSONInput.ts","../../node_modules/graphinius/lib/io/output/JSONOutput.ts","../../node_modules/graphinius/lib/similarities/SetSimilarities.ts","../../node_modules/graphinius/lib/similarities/ScoreSimilarities.ts","../../node_modules/graphinius/lib/perturbation/SimplePerturbations.ts","../../src/common/importGraph.ts","../../src/recommender/TheExpanse.ts","../../node_modules/js-search/dist/commonjs/IndexStrategy/AllSubstringsIndexStrategy.js","../../node_modules/js-search/dist/commonjs/IndexStrategy/ExactWordIndexStrategy.js","../../node_modules/js-search/dist/commonjs/IndexStrategy/PrefixIndexStrategy.js","../../node_modules/js-search/dist/commonjs/IndexStrategy/index.js","../../node_modules/js-search/dist/commonjs/Sanitizer/CaseSensitiveSanitizer.js","../../node_modules/js-search/dist/commonjs/Sanitizer/LowerCaseSanitizer.js","../../node_modules/js-search/dist/commonjs/Sanitizer/index.js","../../node_modules/js-search/dist/commonjs/getNestedFieldValue.js","../../node_modules/js-search/dist/commonjs/SearchIndex/TfIdfSearchIndex.js","../../node_modules/js-search/dist/commonjs/SearchIndex/UnorderedSearchIndex.js","../../node_modules/js-search/dist/commonjs/SearchIndex/index.js","../../node_modules/js-search/dist/commonjs/Tokenizer/SimpleTokenizer.js","../../node_modules/js-search/dist/commonjs/Tokenizer/StemmingTokenizer.js","../../node_modules/js-search/dist/commonjs/StopWordsMap.js","../../node_modules/js-search/dist/commonjs/Tokenizer/StopWordsTokenizer.js","../../node_modules/js-search/dist/commonjs/Tokenizer/index.js","../../node_modules/js-search/dist/commonjs/Search.js","../../node_modules/js-search/dist/commonjs/TokenHighlighter.js","../../node_modules/js-search/dist/commonjs/index.js","../../src/indexers/buildJSSearch.ts","../../src/indexers/shopify/interfaces.ts","../../src/indexers/shopify/appConfig.ts","../../src/index.ts"],"sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","import {ITypedNode} from \"./typed/TypedNode\";\nimport {ITypedEdge} from \"./typed/TypedEdge\";\n\n\n/*----------------------------------------*/\n/*\t\t\t\t\t\t\tBASE GRAPH\t\t\t\t\t\t\t\t*/\n/*----------------------------------------*/\n\n/**\n * @todo maybe refactor to more sensible value(type)s...\n */\nexport enum DIR {\n\tin = \"ins\",\n\tout = \"outs\",\n\tund = \"unds\"\n}\n\nexport enum GraphMode {\n\tINIT,\n\tDIRECTED,\n\tUNDIRECTED,\n\tMIXED\n}\n\nexport interface GraphStats {\n\tmode\t\t\t\t\t: GraphMode;\n\tnr_nodes\t\t\t: number;\n\tnr_und_edges\t: number;\n\tnr_dir_edges\t: number;\n\tdensity_dir\t\t: number;\n\tdensity_und\t\t: number;\n}\n\n\n/**\n * Only gives the best distance to a node in case of multiple direct edges\n */\nexport type MinAdjacencyListDict = {[id: string]: MinAdjacencyListDictEntry};\n\nexport type MinAdjacencyListDictEntry = {[id: string] : number};\n\nexport type MinAdjacencyListArray = Array<Array<number>>;\n\nexport type NextArray = Array<Array<Array<number>>>;\n\n\n\n/*----------------------------------------*/\n/*\t\t\t\t\t\t\tTYPED GRAPH\t\t\t\t\t\t\t\t*/\n/*----------------------------------------*/\n\nexport type TypedNodes = Map<string, Map<string, ITypedNode>>;\nexport type TypedEdges = Map<string, Map<string, ITypedEdge>>;\n\nexport interface TypedGraphStats extends GraphStats {\n\ttyped_nodes: { [key: string]: number };\n\ttyped_edges: { [key: string]: number };\n}\n\nexport type ExpansionInput = ITypedNode | Set<ITypedNode> | ExpansionResult;\n\nexport interface ExpansionConfig {\n\tk?\t\t: number;\n}\n\nexport interface ExpansionResult {\n\tset\t\t: Set<ITypedNode>;\n\tfreq\t: Map<ITypedNode, number>;\n}\n\n/**\n * @todo make it so\n */\n// export type ExpansionResult = Map<ITypedNode, number>;\n\n/**\n * For figuring out abberations to n4j expansion results (sometimes tiny)\n *\n * @todo maybe this is just experimental, maybe not...\n */\ntype Inbounds = {[key: string] : number}; // sourceID => freq of sourceNode\nexport type ExpansionInbounds = {[key: string] : Inbounds};\n\n","const CMD_ENV_LOG = 'G_LOG';\n\nconst GENERIC_TYPES = {\n  Node    : 'GENERIC',\n  Edge    : 'GENERIC',\n  Graph   : 'GENERIC'\n};\n\nconst LOG_LEVELS = {\n  debug: 'debug',\n  production: 'production'\n};\n\n/**\n * Also checking if CMD line argument is given, which might not be the case\n * when running automated test cases.\n */\nfunction runLevel() {\n  let log_level = LOG_LEVELS.production;\n  if ( typeof window === 'undefined' && typeof process !== 'undefined' && process.env && process.env[CMD_ENV_LOG]) {\n    log_level = process.env[CMD_ENV_LOG]\n  }\n  return log_level;\n}\n\nexport {\n  LOG_LEVELS,\n  GENERIC_TYPES,\n  runLevel\n};\n","import {LOG_LEVELS, runLevel} from '../config/run_config';\n\nexport interface LOG_CONFIG {\n\tlog_level: string;\n}\n\nexport enum LogColors {\n\tFgBlack = 30,\n\tFgRed = 31,\n\tFgGreen = 32,\n\tFgYellow = 33,\n\tFgBlue = 34,\n\tFgMagenta = 35,\n\tFgCyan = 36,\n\tFgWhite = 37,\n\n\tBgBlack = 40,\n\tBgRed = 41,\n\tBgGreen = 42,\n\tBgYellow = 43,\n\tBgBlue = 44,\n\tBgMagenta = 45,\n\tBgCyan = 46,\n\tBgWhite = 47\n}\n\nconst DEFAULT_COLOR = 37; // white\n\nclass Logger {\n\tpublic config: LOG_CONFIG;\n\n\tconstructor(config?) {\n\t\tthis.config = config || {\n\t\t\tlog_level: runLevel()\n\t\t};\n\t}\n\n\tlog(msg, color?, bright = false): boolean {\n\t\tif (this.config.log_level === LOG_LEVELS.debug) {\n\t\t\tif ( color ) {\n\t\t\t\tconsole.log.call(console, Logger.colorize(DEFAULT_COLOR, msg, bright));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tconsole.log.call(console, msg);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\terror(err, color?, bright = false): boolean {\n\t\tif (this.config.log_level === LOG_LEVELS.debug) {\n\t\t\tif ( color ) {\n\t\t\t\tconsole.error.call(console, Logger.colorize(color, err, bright));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tconsole.error.call(console, err);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tdir(obj, color?, bright = false): boolean {\n\t\tif (this.config.log_level === LOG_LEVELS.debug) {\n\t\t\tif ( color ) {\n\t\t\t\tconsole.dir.call(console, Logger.colorize(DEFAULT_COLOR, obj, bright));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tconsole.dir.call(console, obj);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tinfo(msg, color?, bright = false): boolean {\n\t\tif (this.config.log_level === LOG_LEVELS.debug) {\n\t\t\tif ( color ) {\n\t\t\t\tconsole.info.call(console, Logger.colorize(DEFAULT_COLOR, msg, bright));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tconsole.info.call(console, msg);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\twarn(msg, color?, bright = false): boolean {\n\t\tif (this.config.log_level === LOG_LEVELS.debug) {\n\t\t\tif ( color ) {\n\t\t\t\tconsole.warn.call(console, Logger.colorize(DEFAULT_COLOR, msg, bright));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tconsole.warn.call(console, msg);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\twrite(msg, color?, bright = false): boolean {\n\t\tif (this.config.log_level === LOG_LEVELS.debug) {\n\t\t\tif ( color ) {\n\t\t\t\tprocess.stdout.write.call(process.stdout, Logger.colorize(DEFAULT_COLOR, msg, bright));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tprocess.stdout.write.call(process.stdout, msg);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n  /**\n   * @todo this one prevents objects from being output in detail ([object Object])\n   * @param color\n   * @param output\n   * @param bright\n   */\n\tstatic colorize(color, output, bright) {\n\t\tlet out_bright = bright ? '\\x1b[1m' : null;\n\t\treturn [out_bright, '\\x1b[', color, 'm', output, '\\x1b[0m'].join('');\n\t}\n\n}\n\nexport {Logger};\n","import {MinAdjacencyListArray, MinAdjacencyListDict, NextArray} from \"../interfaces\";\nimport {IGraph} from \"../base/BaseGraph\";\n\nimport {Logger} from \"../../utils/Logger\";\nimport {IBaseNode} from \"../base/BaseNode\";\nconst logger = new Logger();\n\nconst DEFAULT_WEIGHT = 1;\n\n\nexport interface NumericHandler {\n\ttensor2d: Function;\n\tmatMul: Function;\n}\n\n\nexport interface IComputeGraph {\n\t// REPRESENTATIONS\n\tadjListW(incoming?: boolean, include_self?, self_dist?: number): MinAdjacencyListDict;\n\n\tadjMatrix(): MinAdjacencyListArray;\n\n\tadjMatrixW(incoming?: boolean): MinAdjacencyListArray;\n\n\tnextArray(incoming?: boolean): NextArray;\n\n\t// METRICS\n\ttriadCount(directed?: boolean): number;\n\n\ttriangleCount(directed?: boolean): Promise<number>;\n\n\tglobalCC(directed?: boolean): Promise<number>;\n\n\tlocalCC(directed? : boolean) : Promise<{[key: string]: number}>;\n}\n\n\nclass ComputeGraph implements IComputeGraph {\n\n\tprivate adj_list_uu: Uint32Array;\n\tprivate adj_list_du: Uint32Array;\n\tprivate adj_list_uw: Float32Array;\n\tprivate adj_list_dw: Float32Array;\n\n\n\tconstructor(private _g: IGraph, private _numeric?: NumericHandler) { }\n\n\n\tcheckNumericHandler() {\n\t\tif (!this._numeric || !this._numeric.matMul) {\n\t\t\tthrow new Error(\"Tensorflow & TF matMul function must be present for fast numeric computations.\");\n\t\t}\n\t}\n\n\n\t/**\n\t * @param incoming\n\t * @todo analyze and make faster\n\t */\n\tnextArray(incoming: boolean = false): NextArray {\n\t\tlet next = [],\n\t\t\tnode_keys = Object.keys(this._g.getNodes());\n\n\t\tconst adjDict = this.adjListW(incoming, true, 0);\n\n\t\tfor (let i = 0; i < this._g.nrNodes(); ++i) {\n\t\t\tnext.push([]);\n\t\t\tfor (let j = 0; j < this._g.nrNodes(); ++j) {\n\t\t\t\tnext[i].push([]);\n\t\t\t\tnext[i][j].push(i === j ? j : isFinite(adjDict[node_keys[i]][node_keys[j]]) ? j : null);\n\t\t\t}\n\t\t}\n\t\treturn next;\n\t}\n\n\n\tadjMatrix(): MinAdjacencyListArray {\n\t\tlet adjList = [],\n\t\t\tnode_keys = Object.keys(this._g.getNodes());\n\n\t\tconst adjDict = this.adjListW();\n\n\t\tfor (let i = 0; i < this._g.nrNodes(); ++i) {\n\t\t\tadjList.push([]);\n\t\t\tfor (let j = 0; j < this._g.nrNodes(); ++j) {\n\t\t\t\tadjList[i].push(i === j ? 0 : isFinite(adjDict[node_keys[i]][node_keys[j]]) ? 1 : 0);\n\t\t\t}\n\t\t}\n\t\treturn adjList;\n\t}\n\n\n\t/**\n\t * @todo rename? it's actually a weight matrix...\n\t *\n\t * This function iterates over the adjDict in order to use it's advantage\n\t * of being able to override edges if edges with smaller weights exist\n\t *\n\t * However, the order of nodes in the array represents the order of nodes\n\t * at creation time, no other implicit alphabetical or collational sorting.\n\t *\n\t * This has to be considered when further processing the result\n\t *\n\t * @param incoming whether or not to consider incoming edges\n\t * @param include_self contains a distance to itself?\n\t * @param self_dist default distance to self\n\t */\n\tadjMatrixW(incoming: boolean = false, include_self = false, self_dist = 0): MinAdjacencyListArray {\n\t\tlet adjList = [],\n\t\t\tnode_keys = Object.keys(this._g.getNodes());\n\n\t\tconst adjDict = this.adjListW(incoming, include_self, self_dist);\n\n\t\tfor (let i = 0; i < this._g.nrNodes(); ++i) {\n\t\t\tadjList.push([]);\n\t\t\tfor (let j = 0; j < this._g.nrNodes(); ++j) {\n\t\t\t\tadjList[i].push(i === j ? self_dist : isFinite(adjDict[node_keys[i]][node_keys[j]]) ? adjDict[node_keys[i]][node_keys[j]] : Number.POSITIVE_INFINITY);\n\t\t\t}\n\t\t}\n\t\treturn adjList;\n\t}\n\n\n\t/**\n\t * @todo force directed / undirected\n\t * \t\t\t -> take undirected edge as 2 directed ones?\n\t * \t\t\t -> take directed edge as undirected?\n\t *\n\t * @param incoming whether or not to consider incoming edges\n\t * @param include_self contains a distance to itself?\n\t * @param self_dist default distance to self\n\t */\n\tadjListW(incoming: boolean = false, include_self = false, self_dist = 0): MinAdjacencyListDict {\n\t\tlet adj_list_dict: MinAdjacencyListDict = {},\n\t\t\tnodes = this._g.getNodes(),\n\t\t\tcur_dist: number,\n\t\t\tkey: string,\n\t\t\tcur_edge_weight: number;\n\n\t\tfor (key in nodes) {\n\t\t\tadj_list_dict[key] = {};\n\t\t\tif (include_self) {\n\t\t\t\tadj_list_dict[key][key] = self_dist;\n\t\t\t}\n\t\t}\n\t\tfor (key in nodes) {\n\t\t\tlet neighbors = incoming ? nodes[key].reachNodes().concat(nodes[key].prevNodes()) : nodes[key].reachNodes();\n\n\t\t\tneighbors.forEach((ne) => {\n\t\t\t\tcur_dist = adj_list_dict[key][ne.node.getID()] || Number.POSITIVE_INFINITY;\n\t\t\t\tcur_edge_weight = isNaN(ne.edge.getWeight()) ? DEFAULT_WEIGHT : ne.edge.getWeight();\n\n\t\t\t\tif (cur_edge_weight < cur_dist) {\n\t\t\t\t\tadj_list_dict[key][ne.node.getID()] = cur_edge_weight;\n\n\t\t\t\t\tif (incoming) { // we need to update the 'inverse' entry as well\n\t\t\t\t\t\tadj_list_dict[ne.node.getID()][key] = cur_edge_weight;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tadj_list_dict[key][ne.node.getID()] = cur_dist;\n\n\t\t\t\t\tif (incoming) {\n\t\t\t\t\t\tadj_list_dict[ne.node.getID()][key] = cur_dist;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn adj_list_dict;\n\t}\n\n\n\t/**-------------------------------------------------------------\n\t * \t\t\t\tTriad, triangle, CC & transitivity (global CC)\n\t *\t\t\t\t@todo refactor out into own module:\n\t *\t\t\t\t  - name: `general metrics` ?\n\t *\t\t\t\t\t- modularity / connectivity / CC & Trans\n\t *-------------------------------------------------------------\n\t */\n\n\t/**\n\t * @description `triad`: is either a completed triangle or a potential triangle, \n\t * \t\t\t\t\t\t\tmeaning a connection between 3 nodes that is lacking just 1 edge.\n\t * \t\t\t\t\t\t\t`triplet`: is three nodes that are connected by either two (open triplet) \n\t * \t\t\t\t\t\t\tor three (closed triplet) undirected ties\n\t * \t\t\t\t\t\t\ttriad == triplet\n\t * @description count all 2-triads\n\t\t* \t\t\t\t\t  UN-directed scenario for earch node: all pairwise connections could form a triangle\n\t\t* \t\t\t\t\t  directed scenario for each node: -ins could form triangles with -outs (and vice versa)\n\t *\n\t * @todo this only works for nodes without self-loops !!!\n\t *\n\t * @param directed directed or undirected\n\t */\n\ttriadCount(directed = false): number {\n\t\tlet triangle_count = 0;\n\t\tconst nodes = Object.values(this._g.getNodes());\n\t\tlet deg;\n\n\t\tfor ( let n of nodes ) {\n\t\t\tif ( directed ) {\n\t\t\t\ttriangle_count += ( n.in_deg - n.self_in_deg ) * ( n.out_deg - n.self_out_deg );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdeg = n.deg - n.self_deg;\n\t\t\t\ttriangle_count += deg * ( deg - 1 ) / 2;\n\t\t\t}\n\t\t}\n\t\treturn triangle_count;\n\t}\n\n\n\t/**\n\t * @description how many triangles (A-B-C, or A->B->C) are there in the graph\n\t * \t\t\t\t\t\t\tIn directed graphs, each triangle is seen thrice (from A, B, C)\n\t * \t\t\t\t\t\t\tIn undirected graphs, each triangle is seen six times (from A, B, C, but each in 2 directions)\n\t * @param directed directed or undirected network\n\t */\n\tasync triangleCount(directed = false): Promise<number> {\n\t\tthis.checkNumericHandler();\n\t\tconst adj_list = this.adjMatrix();\n\t\tconst a = this._numeric.tensor2d(adj_list);\n\t\tconst aux2 = await a.matMul(a).array();\n\t\tconst aux3 = await a.matMul(aux2).array();\n\t\t// logger.log(aux3);\n\n\t\tlet trace = 0;\n\t\tfor (let i = 0; i < aux3.length; i++) {\n\t\t\ttrace += aux3[i][i];\n\t\t}\n\t\treturn directed ? trace / 3 : trace / 6;\n\t}\n\n\n\t/**\n\t * @description transitivity (or global clustering coefficient, gCC) is the ratio\n\t * \t\t\t\t\t\t\tof actual triangles to potential triangles, or\n\t * \t\t\t\t\t\t\t(nr. of closed triplets / nr. of all triplets)\n\t * \t\t\t\t\t\t\tIt therefore measures the connection potential of the whole graph,\n\t * \t\t\t\t\t\t\tthe higher the gCC the lower the future connection potential.\n\t * @description should equal the average (local) clustering coefficients of all nodes\n\t * \n\t * @todo test that avg(lCC) == gCC\n\t * @todo there are 4 different ways to define a triplet closure in DIRECTED graphs\n\t * @todo using the `undirected` formula results are not consistent with networkx\n\t * @todo research & correct the $G <-> networkx inconsistency\n\t * @param directed directed or undirected network\n\t */\n\tasync globalCC(directed = false): Promise<number> {\n\t\tconst triangles = await this.triangleCount(directed);\n\t\tconst triads = this.triadCount(directed);\n\t\treturn 3 * triangles / triads;\n\t}\n\n\n\t/**\n\t * @description The CC (also `local` CC) measures how complete the neighborhood of a node is,\n\t * \t\t\t\t\t\t\ti.e. (completed triangles / `potential` triangles), where a potential triangle\n\t * \t\t\t\t\t\t\tcould form by adding 1 edge between\thitherto unconnected neighbors.\n\t * \t\t\t\t\t\t\tThis can be measured by \t\t\t\t\t\t\t\n\t * @param directed directed or undirected network\n\t */\n\tasync localCC(directed = false) : Promise<{[key: string]: number}> {\n\t\tthis.checkNumericHandler();\n\t\tconst result = {};\n\t\tconst adj_list = this.adjMatrix();\n\t\tconst a = this._numeric.tensor2d(adj_list);\n\t\tconst aux2 = await a.matMul(a).array();\n\t\tconst aux3 = await a.matMul(aux2).array();\n\t\t/**\n\t\t * @todo ensure node order is equivalent to aux3 ordering - HOW ??\n\t\t */\n\t\tlet deg: number;\n\t\tlet node: IBaseNode;\n\t\tlet cc_i: number; // intermediate\n\t\tconst keys = Object.keys(this._g.getNodes());\n\n\t\tfor ( let i in aux3[0] ) {\n\t\t\tnode = this._g.getNodeById(keys[i]);\n\t\t\tdeg = directed ? node.in_deg + node.out_deg : node.deg;\n\t\t\tcc_i = (aux3[i][i] / (deg * (deg-1))) || 0;\n\t\t\tresult[i] = directed ? 2 * cc_i : cc_i;\n\t\t}\n\t\treturn result;\n\t}\n\n\n\n}\n\n\nexport {\n\tComputeGraph\n}\n","/**\n * @param cbs\n * @param context this pointer to the DFS or DFSVisit function\n */\nfunction execCallbacks(cbs : Array<Function>, context?) {\n  cbs.forEach( function(cb) {\n    if ( typeof cb === 'function' ) {\n      cb(context);\n    }\n    else {\n      throw new Error('Provided callback is not a function.');\n    }\n  });\n}\n\nexport { execCallbacks };","import {GraphMode, GraphStats, MinAdjacencyListDict} from '../core/interfaces';\nimport * as $N from '../core/base/BaseNode';\nimport * as $E from '../core/base/BaseEdge';\nimport * as $G from '../core/base/BaseGraph';\nimport * as $CB from '../utils/CallbackUtils';\n\n\nexport interface BFS_Config {\n\tresult\t\t\t:\t{[id: string]: BFS_ResultEntry};\n\tcallbacks\t\t:\tBFS_Callbacks;\n\tdir_mode\t\t:\tGraphMode;\n\tmessages?\t\t: {};\n\tfilters?\t\t: any;\n}\n\nexport interface BFS_ResultEntry {\n\tdistance\t:\tnumber;\n\tparent\t\t:\t$N.IBaseNode;\n\tcounter\t\t: number; // order of discovery\n}\n\nexport interface BFS_Callbacks {\n\tinit_bfs?\t\t\t : Array<Function>;\n\tnode_unmarked? : Array<Function>;\n\tnode_marked?\t : Array<Function>;\n\tsort_nodes?\t\t : Function;\n}\n\nexport interface BFS_Scope {\n\t// marked \t  \t: {[id: string] : boolean};\n\tnodes\t\t  \t: {[id: string] : $N.IBaseNode};\n\tqueue\t\t\t\t: Array<$N.IBaseNode>;\n\tcurrent\t\t\t: $N.IBaseNode;\n\tnext_node\t\t: $N.IBaseNode;\n\tnext_edge\t\t: $E.IBaseEdge;\n\troot_node\t\t: $N.IBaseNode;\n\tadj_nodes\t\t: Array<$N.NeighborEntry>;\n}\n\n\n/**\n * Breadth first search - usually performed to see\n * reachability etc. Therefore we do not want 'segments'\n * or 'components' of our graph, but simply one well\n * defined result segment covering the whole graph.\n * \n * @param graph the graph to perform BFS on\n * @param v the vertex to use as a start vertex\n * @param config an optional config object, will be\n * automatically instantiated if not passed by caller\n * @returns {{}}\n * @constructor\n */\nfunction BFS(graph \t : $G.IGraph, \n\t\t\t\t\t\t v \t\t\t : $N.IBaseNode,\n\t\t\t\t\t\t config? : BFS_Config) : {[id: string] : BFS_ResultEntry} {\n\n\tconfig = config || prepareBFSStandardConfig();\n\tlet callbacks = config.callbacks;\n\tlet dir_mode = config.dir_mode;\n\n\t/**\n\t * We are not traversing an empty graph...\n\t */\n\tif ( graph.getMode() === GraphMode.INIT ) {\n\t\tthrow new Error('Cowardly refusing to traverse graph without edges.');\n\t}\n\t/**\n\t * We are not traversing a graph taking NO edges into account\n\t */\n\tif ( dir_mode === GraphMode.INIT ) {\n\t\tthrow new Error('Cannot traverse a graph with dir_mode set to INIT.');\n\t}\n\n\t// scope to pass to callbacks at different stages of execution\n\tlet bfsScope : BFS_Scope = {\n\t\t// marked: {},\n\t\tnodes: graph.getNodes(),\n\t\tqueue: [],\n\t\tcurrent: null,\n\t\tnext_node: null,\n\t\tnext_edge: null,\n\t\troot_node: v,\n\t\tadj_nodes: []\n\t};\n\n  /**\n\t * HOOK 1: BFS INIT\n\t */\n\tif ( callbacks.init_bfs ) {\n\t\t$CB.execCallbacks(callbacks.init_bfs, bfsScope);\n\t}\n\n\tbfsScope.queue.push(v);\n\t\n\tlet i = 0;\n\twhile ( i < bfsScope.queue.length ) {\n\t\tbfsScope.current = bfsScope.queue[i++];\n\t\t\n\t\t/**\n\t\t * Do we move only in the directed subgraph,\n\t\t * undirected subgraph or complete (mixed) graph?\n\t\t */\n\t\tif ( dir_mode === GraphMode.MIXED ) {\n\t\t\tbfsScope.adj_nodes = bfsScope.current.reachNodes();\n\t\t}\n\t\telse if ( dir_mode === GraphMode.UNDIRECTED ) {\n\t\t\tbfsScope.adj_nodes = bfsScope.current.connNodes();\n\t\t}\n\t\telse if ( dir_mode === GraphMode.DIRECTED ) {\n\t\t\tbfsScope.adj_nodes = bfsScope.current.nextNodes();\n\t\t}\n\t\telse {\n\t\t\tbfsScope.adj_nodes = [];\n\t\t}\n\n\t\t/**\n\t\t * HOOK 2 - Sort adjacent nodes\n\t\t */\n\t\tif ( typeof callbacks.sort_nodes === 'function' ) {\n\t\t\tcallbacks.sort_nodes(bfsScope);\n\t\t}\n\t\t\n\t\tfor ( let adj_idx in bfsScope.adj_nodes ) {\n\t\t\tbfsScope.next_node = bfsScope.adj_nodes[adj_idx].node;\n\t\t\tbfsScope.next_edge = bfsScope.adj_nodes[adj_idx].edge;\n\t\t\t/**\n\t\t\t * HOOK 3 - Node unmarked\n\t\t\t */\n\t\t\tif ( config.result[bfsScope.next_node.getID()].distance === Number.POSITIVE_INFINITY ) {\n\t\t\t\tif ( callbacks.node_unmarked ) {\n\t\t\t\t\t$CB.execCallbacks(callbacks.node_unmarked, bfsScope);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t/**\n\t\t\t\t * HOOK 4 - Node marked\n\t\t\t\t */\n\t\t\t\tif ( callbacks.node_marked ) {\n\t\t\t\t\t$CB.execCallbacks(callbacks.node_marked, bfsScope);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn config.result;\n}\n\n\nfunction prepareBFSStandardConfig() {\n\tlet config : BFS_Config = {\n\t\tresult: {},\n\t\tcallbacks: {\n\t\t\tinit_bfs: [],\n\t\t\tnode_unmarked: [],\n\t\t\tnode_marked: [],\n\t\t\tsort_nodes: undefined\n\t\t},\n\t\tdir_mode: GraphMode.MIXED,\n\t\tmessages: {},\n\t\tfilters: {}\n\t},\n\t\tresult = config.result,\n\t\tcallbacks = config.callbacks;\n\n\tlet count = 0;\n\tlet counter = function() {\n\t\treturn count++;\n\t};\n\n\n\t/**\n\t * Standard INIT callback\n \t */\n\tlet initBFS = function( context : BFS_Scope ) {\n\t\tfor ( let key in context.nodes ) {\n\t\t\tconfig.result[key] = {\n\t\t\t\tdistance : Number.POSITIVE_INFINITY,\n\t\t\t\tparent \t : null,\n\t\t\t\tcounter\t : -1\n\t\t\t};\n\t\t}\n\t\t// initialize root node entry\n\t\tconfig.result[context.root_node.getID()] = {\n\t\t\tdistance\t: 0,\n\t\t\tparent\t\t: context.root_node,\n\t\t\tcounter\t\t: counter()\n\t\t};\n\t};\n\tcallbacks.init_bfs.push( initBFS );\n\n\t// Standard Node unmarked callback\n\t// have to populate respective result entry\n\tlet nodeUnmarked = function( context: BFS_Scope ) {\n\t\tconfig.result[context.next_node.getID()] = {\n\t\t\tdistance : result[context.current.getID()].distance + 1,\n\t\t\tparent \t : context.current,\n\t\t\tcounter\t : counter()\n\t\t};\n\t\tcontext.queue.push(context.next_node);\n\t};\n\tcallbacks.node_unmarked.push( nodeUnmarked );\n\n\treturn config;\n}\n\n\nexport { BFS, prepareBFSStandardConfig };\n","import {GraphMode, GraphStats, MinAdjacencyListDict} from '../core/interfaces';\nimport * as $N from '../core/base/BaseNode';\nimport * as $G from '../core/base/BaseGraph';\nimport * as $CB from '../utils/CallbackUtils';\n\n\nexport interface DFS_Config {\n  visit_result: {};\n  callbacks: DFS_Callbacks;\n  dir_mode: GraphMode;\n  dfs_visit_marked: {[id: string] : boolean};\n  messages?: {};\n  filters?: any;\n}\n\nexport interface DFS_Callbacks {\n\tinit_dfs?\t\t\t    : Array<Function>;\n\tinit_dfs_visit?\t\t: Array<Function>;\n\tnode_popped?\t \t\t: Array<Function>;\n\tnode_marked?\t\t\t: Array<Function>;\n\tnode_unmarked?\t\t: Array<Function>;\n\tadj_nodes_pushed?\t: Array<Function>;\n\tsort_nodes?\t\t\t\t: Function;\n}\n\nexport interface StackEntry {\n\tnode\t\t: $N.IBaseNode;\n\tparent\t: $N.IBaseNode;\n  weight? : number;\n}\n\nexport interface DFSVisit_Scope {\n\tstack \t\t\t\t: Array<StackEntry>;\n\tadj_nodes\t\t\t: Array<$N.NeighborEntry>;\n\tstack_entry \t: StackEntry;\n\tcurrent\t\t\t\t: $N.IBaseNode;\n\tcurrent_root\t: $N.IBaseNode;\n}\n\nexport interface DFS_Scope {\n\tmarked \t  : {[id: string] : boolean};\n\tnodes\t\t  : {[id: string] : $N.IBaseNode};\n}\n\n\n/**\n * DFS Visit - one run to see what nodes are reachable\n * from a given \"current\" root node\n *\n * @param graph\n * @param current_root\n * @param config\n * @returns {{}}\n * @constructor\n */\nfunction DFSVisit(graph \t\t\t\t: $G.IGraph,\n\t\t\t\t\t\t\t\t\tcurrent_root \t: $N.IBaseNode,\n                  config?       : DFS_Config) {\n\n\t// scope to pass to callbacks at different stages of execution\n\tlet dfsVisitScope : DFSVisit_Scope = {\n\t\tstack\t\t\t\t\t: [],\n\t\tadj_nodes\t\t\t: [],\n\t\tstack_entry\t\t: null,\n\t\tcurrent\t\t\t\t: null,\n\t\tcurrent_root\t: current_root\n\t};\n  \n  config = config || prepareDFSVisitStandardConfig();\n  let callbacks = config.callbacks,\n      dir_mode = config.dir_mode;\n\n\t/**\n\t * We are not traversing an empty graph...\n\t */\n\tif ( graph.getMode() === GraphMode.INIT ) {\n\t\tthrow new Error('Cowardly refusing to traverse graph without edges.');\n\t}\n  /**\n\t * We are not traversing a graph taking NO edges into account\n\t */\n\tif ( dir_mode === GraphMode.INIT ) {\n\t\tthrow new Error('Cannot traverse a graph with dir_mode set to INIT.');\n\t}\n\n\t/**\n\t * HOOK 1 - INIT (INNER DFS VISIT):\n\t * Initializing a possible result object,\n\t * possibly with the current_root;\n\t */\n\tif ( callbacks.init_dfs_visit ) {\n\t\t$CB.execCallbacks(callbacks.init_dfs_visit, dfsVisitScope);\n\t}\n\n\t// Start by pushing current root to the stack\n\tdfsVisitScope.stack.push({\n\t\tnode\t\t: current_root,\n\t\tparent\t: current_root,\n    weight  : 0 // initial weight cost from current_root\n\t});\n\n\n\twhile ( dfsVisitScope.stack.length ) {\n\t\tdfsVisitScope.stack_entry = dfsVisitScope.stack.pop();\n\t\tdfsVisitScope.current = dfsVisitScope.stack_entry.node;\n    \n\t\t/**\n\t\t * HOOK 2 - AQUIRED CURRENT NODE / POPPED NODE\n\t\t */\n\t\tif ( callbacks.node_popped ) {\n\t\t\t$CB.execCallbacks(callbacks.node_popped, dfsVisitScope);\n\t\t}\n\n\t\tif ( !config.dfs_visit_marked[dfsVisitScope.current.getID()] ) {\n\t\t\tconfig.dfs_visit_marked[dfsVisitScope.current.getID()] = true;\n\n\t\t\t/**\n\t\t\t * HOOK 3 - CURRENT NODE UNMARKED\n\t\t\t */\n\t\t\tif ( callbacks.node_unmarked ) {\n\t\t\t\t$CB.execCallbacks(callbacks.node_unmarked, dfsVisitScope);\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Do we move only in the directed subgraph,\n\t\t\t * undirected subgraph or complete (mixed) graph?\n\t\t\t */\n\t\t\tif ( dir_mode === GraphMode.MIXED ) {\n\t\t\t\tdfsVisitScope.adj_nodes = dfsVisitScope.current.reachNodes();\n\t\t\t}\n\t\t\telse if ( dir_mode === GraphMode.UNDIRECTED ) {\n\t\t\t\tdfsVisitScope.adj_nodes = dfsVisitScope.current.connNodes();\n\t\t\t}\n\t\t\telse if ( dir_mode === GraphMode.DIRECTED ) {\n\t\t\t\tdfsVisitScope.adj_nodes = dfsVisitScope.current.nextNodes();\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * HOOK 4 - SORT ADJACENT NODES\n\t\t\t */\n\t\t\tif ( typeof callbacks.sort_nodes === 'function' ) {\n\t\t\t\tcallbacks.sort_nodes(dfsVisitScope);\n\t\t\t}\n\n\t\t\tfor ( let adj_idx in dfsVisitScope.adj_nodes ) {\n\t\t\t\t/**\n\t\t\t\t * HOOK 5 - NODE OR EDGE TYPE CHECK...\n\t\t\t\t * LATER !!\n\t\t\t\t */\n        if ( callbacks ) {\n        }\n        \n        \n\t\t\t\tdfsVisitScope.stack.push({\n\t\t\t\t\tnode: dfsVisitScope.adj_nodes[adj_idx].node,\n\t\t\t\t\tparent: dfsVisitScope.current,\n          weight: dfsVisitScope.adj_nodes[adj_idx].edge.getWeight()\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * HOOK 6 - ADJACENT NODES PUSHED - LEAVING CURRENT NODE\n\t\t\t */\n\t\t\tif ( callbacks.adj_nodes_pushed ) {\n\t\t\t\t$CB.execCallbacks(callbacks.adj_nodes_pushed, dfsVisitScope);\n\t\t\t}\n\n\t\t}\n\t\telse {\n\t\t\t/**\n\t\t\t * HOOK 7 - CURRENT NODE ALREADY MARKED\n\t\t\t */\n\t\t\tif ( callbacks.node_marked ) {\n\t\t\t\t$CB.execCallbacks(callbacks.node_marked, dfsVisitScope);\n\t\t\t}\n\t\t}\n\t}\n\n  return config.visit_result;\n\n\n}\n/**\n * Depth first search - used for reachability / exploration\n * of graph structure and as a basis for topological sorting\n * and component / community analysis.\n * Because DFS can be used as a basis for many other algorithms,\n * we want to keep the result as generic as possible to be\n * populated by the caller rather than the core DFS algorithm.\n *\n * @param graph\n * @param root\n * @param config\n * @returns {{}[]}\n * @constructor\n */\nfunction DFS( graph \t\t  : $G.IGraph,\n\t\t\t\t\t\t\troot      \t: $N.IBaseNode,\n\t\t\t\t\t\t\tconfig?\t    : DFS_Config) {\n                \n  config = config || prepareDFSStandardConfig();\n  let callbacks = config.callbacks,\n      dir_mode = config.dir_mode;\n      \n\tif ( graph.getMode() === GraphMode.INIT ) {\n\t\tthrow new Error('Cowardly refusing to traverse graph without edges.');\n\t}\n\tif ( dir_mode === GraphMode.INIT ) {\n\t\tthrow new Error('Cannot traverse a graph with dir_mode set to INIT.');\n\t}\n  \n\tlet dfsScope : DFS_Scope = {\n      marked \t  : {},\n      nodes \t  : graph.getNodes()\n  };\n\n\t/**\n\t * HOOK 1 - INIT (OUTER DFS)\n\t */\n\tif ( callbacks.init_dfs ) {\n\t\t$CB.execCallbacks(callbacks.init_dfs, dfsScope);\n\t}\n\n\tcallbacks.adj_nodes_pushed = callbacks.adj_nodes_pushed || [];\n\tlet markNode = function ( context : DFSVisit_Scope ) {\n\t\tdfsScope.marked[context.current.getID()] = true;\n\t};\n\tcallbacks.adj_nodes_pushed.push(markNode);\n  \n  \n  // We need to put our results into segments\n  // for easy counting of 'components'\n  // TODO refactor for count & counter...\n  let dfs_result = [{}];\n  let dfs_idx = 0;\n  let count = 0;\n\tlet counter = function() {\n\t\treturn count++;\n\t};\n  \n  /**\n   * We not only add new nodes to the result object\n   * of DFSVisit, but also to it's appropriate\n   * segment of the dfs_result object\n   */\n  let addToProperSegment = function( context: DFSVisit_Scope ) {\n    dfs_result[dfs_idx][context.current.getID()] = {\n\t\t\tparent \t: context.stack_entry.parent,\n\t\t\tcounter : counter()\n\t\t};\n  };\n  \n  // check if a callbacks object has been instantiated\n  if ( callbacks && callbacks.node_unmarked ) {\n    callbacks.node_unmarked.push(addToProperSegment);\n  }\n  \n  // Start with root node, no matter what\n  DFSVisit(graph, root, config);\n\n  // Now take the rest in 'normal' order\n\tfor( let node_key in dfsScope.nodes ) {\n    if ( !dfsScope.marked[node_key] ) {\n      // Next segment in dfs_results\n      dfs_idx++;\n      dfs_result.push({});\n      // Explore and fill next subsegment\n      DFSVisit(graph, dfsScope.nodes[node_key], config);\n    }\n\t}\n  \n  // console.dir(config.visit_result);\n  return dfs_result;\n}\n\n\n/**\n * This is the only place in which a config object\n * is instantiated (except manually, of course)\n * \n * Therefore, we do not take any arguments\n */\nfunction prepareDFSVisitStandardConfig() {\n\n  let config : DFS_Config = {\n    visit_result: {},\n    callbacks: {},\n    messages: {},\n    dfs_visit_marked: {},\n    dir_mode: GraphMode.MIXED\n  },\n  result = config.visit_result,\n  callbacks = config.callbacks;\n              \n  // internal letiable for order of visit\n  // during DFS Visit                      \n  let count = 0;\n\tlet counter = function() {\n\t\treturn count++;\n\t};\n  \n\tcallbacks.init_dfs_visit = callbacks.init_dfs_visit || [];\n\tlet initDFSVisit = function( context : DFSVisit_Scope ) {\n\t\tresult[context.current_root.getID()] = {\n\t\t\tparent \t: context.current_root\n\t\t};\n\t};\n\tcallbacks.init_dfs_visit.push(initDFSVisit);\n  \n\tcallbacks.node_unmarked = callbacks.node_unmarked || [];\n\tlet setResultEntry = function( context : DFSVisit_Scope ) {\n\t\tresult[context.current.getID()] = {\n\t\t\tparent \t: context.stack_entry.parent,\n\t\t\tcounter : counter()\n\t\t};\n\t};\n\tcallbacks.node_unmarked.push(setResultEntry);\n  \n  return config;\n}\n\n\n/**\n * First instantiates config file for DFSVisit, then\n * enhances it with outer DFS init callback\n */\nfunction prepareDFSStandardConfig() {                                \n\t// First prepare DFS Visit callbacks\n\tlet config = prepareDFSVisitStandardConfig(),\n      callbacks = config.callbacks;\n      // result = config.visit_result;\n  \n\t// Now add outer DFS INIT callback\n\tcallbacks.init_dfs = callbacks.init_dfs || [];\n\tlet setInitialResultEntries = function( context : DFS_Scope ) {\n\t\t// for ( let node_id in context.nodes ) {\n\t\t// \tresult[node_id] = {\n\t\t// \t\tparent: null,\n\t\t// \t\tcounter: -1\n\t\t// \t}\n\t\t// }\n\t};\n\tcallbacks.init_dfs.push(setInitialResultEntries);\n\n  return config;\n}\n\nexport { DFSVisit, \n         DFS,\n         prepareDFSVisitStandardConfig,\n         prepareDFSStandardConfig\n       };\n","export enum BinaryHeapMode {\n  MIN,\n  MAX\n}\n\nexport interface PositionHeapEntry {\n  score: number;\n  position: number;\n}\n\nexport interface IBinaryHeap {\n  // Helper methods\n  getMode(): BinaryHeapMode;\n  getArray(): Array<any>;\n  size(): number;\n  getEvalPriorityFun(): Function;\n  evalInputScore(obj: any): number;\n  getEvalObjIDFun(): Function;\n  evalInputObjID(obj: any): any;\n\n  // Actual heap operations\n  insert(obj: any): void;\n  // reInsert(obj: any): void;\n  remove(obj: any): any;\n  peek(): any;\n  pop(): any;\n  find(obj: any): any;\n\n  // Just temporarily, for debugging\n  getPositions(): any;\n}\n\n\n/**\n * We only support unique object ID's for now !!!\n * @TODO Rename into \"ObjectBinaryHeap\" or such...\n */\nclass BinaryHeap implements IBinaryHeap {\n  _nr_removes : number = 0; // just for debugging\n  private _array = [];\n  private _positions: { [id: string]: PositionHeapEntry } = {};\n\n  /**\n   * Mode of a min heap should only be set upon\n   * instantiation and never again afterwards...\n   * @param _mode MIN or MAX heap\n   * @param _evalObjID function to determine an object's identity\n   * @param _evalPriority function to determine an objects score\n   */\n  constructor(private _mode = BinaryHeapMode.MIN,\n    private _evalPriority = (obj: any): number => {\n      if (typeof obj !== 'number' && typeof obj !== 'string') {\n        return NaN;\n      }\n      if (typeof obj === 'number') {\n        return obj | 0;\n      }\n      return parseInt(obj);\n    },\n    private _evalObjID = (obj: any): any => {\n      return obj;\n    }\n  ) {\n\n  }\n\n  getMode(): BinaryHeapMode {\n    return this._mode;\n  }\n\n  getArray(): Array<any> {\n    return this._array;\n  }\n\n  getPositions() {\n    return this._positions;\n  }\n\n  size(): number {\n    return this._array.length;\n  }\n\n  getEvalPriorityFun(): Function {\n    return this._evalPriority;\n  }\n\n  evalInputScore(obj: any): number {\n    return this._evalPriority(obj);\n  }\n\n  getEvalObjIDFun(): Function {\n    return this._evalObjID;\n  }\n\n  evalInputObjID(obj: any): any {\n    return this._evalObjID(obj);\n  }\n\n  peek(): any {\n    return this._array[0];\n  }\n\n  pop() {\n    if (this.size()) {\n      return this.remove(this._array[0]);\n    }\n  }\n\n  find(obj: any): any {\n    let pos = this.getNodePosition(obj);\n    return this._array[pos];\n  }\n\n  /**\n   * Insert - Adding an object to the heap\n   * @param obj the obj to add to the heap\n   * @returns {number} the objects index in the internal array\n   */\n  insert(obj: any) {\n    if (isNaN(this._evalPriority(obj))) {\n      throw new Error(\"Cannot insert object without numeric priority.\")\n    }\n\n    /**\n     * @todo if we keep the unique ID stuff, check for it here and throw an Error if needed...\n     */\n\n    this._array.push(obj);\n    this.setNodePosition(obj, this.size() - 1);\n    this.trickleUp(this.size() - 1);\n  }\n\n  remove(obj: any): any {\n    this._nr_removes++;\n\n    if (isNaN(this._evalPriority(obj))) {\n      throw new Error('Object invalid.');\n    }\n\n    let pos = this.getNodePosition(obj),\n        found = this._array[pos] != null ? this._array[pos] : null;\n\n    if (found === null) {\n      return undefined;\n    }\n    \n    let last_array_obj = this._array.pop();\n    this.removeNodePosition(obj);\n\n    if ( this.size() && found !== last_array_obj ) {\n      this._array[pos] = last_array_obj;\n      this.setNodePosition(last_array_obj, pos);\n\n      this.trickleUp(pos);\n      this.trickleDown(pos);\n    }\n\n    return found;\n  }\n\n\n  private trickleDown(i: number) {\n    let parent = this._array[i];\n\n    while (true) {\n      let right_child_idx = (i + 1) * 2,\n        left_child_idx = right_child_idx - 1,\n        right_child = this._array[right_child_idx],\n        left_child = this._array[left_child_idx],\n        swap = null;\n\n      // check if left child exists && is larger than parent\n      if (left_child_idx < this.size() && !this.orderCorrect(parent, left_child)) {\n        swap = left_child_idx;\n      }\n\n      // check if right child exists && is larger than parent\n      if (right_child_idx < this.size() && !this.orderCorrect(parent, right_child)\n        && !this.orderCorrect(left_child, right_child)) {\n        swap = right_child_idx;\n      }\n\n      if (swap === null) {\n        break;\n      }\n\n      // we only have to swap one child, doesn't matter which one\n      this._array[i] = this._array[swap];\n      this._array[swap] = parent;\n\n      // console.log(`Trickle down: swapping ${this._array[i]} and ${this._array[swap]}`);\n      this.setNodePosition(this._array[i], i);\n      this.setNodePosition(this._array[swap], swap);\n\n      i = swap;\n    }\n  }\n\n  private trickleUp(i: number) {\n    let child = this._array[i];\n\n    // Can only trickle up from positive levels\n    while (i) {\n      let parent_idx = Math.floor((i + 1) / 2) - 1,\n        parent = this._array[parent_idx];\n      if (this.orderCorrect(parent, child)) {\n        break;\n      }\n      else {\n        this._array[parent_idx] = child;\n        this._array[i] = parent;\n\n        // console.log(`Trickle up: swapping ${child} and ${parent}`);\n        this.setNodePosition(child, parent_idx);\n        this.setNodePosition(parent, i);\n\n        i = parent_idx;\n      }\n    }\n  }\n\n  private orderCorrect(obj_a, obj_b) {\n    let obj_a_pr = this._evalPriority(obj_a);\n    let obj_b_pr = this._evalPriority(obj_b);\n    if (this._mode === BinaryHeapMode.MIN) {\n      return obj_a_pr <= obj_b_pr;\n    }\n    else {\n      return obj_a_pr >= obj_b_pr;\n    }\n  }\n\n\n  /**\n   * Superstructure to enable search in BinHeap in O(1)\n   * @param obj\n   * @param pos\n   */\n  private setNodePosition(obj: any, pos: number) : void {\n    if ( obj == null || pos == null || pos !== (pos|0) ) {\n      throw new Error('minium required arguments are obj and new_pos');\n    }\n    let pos_obj: PositionHeapEntry = {\n      score: this.evalInputScore(obj),\n      position: pos\n    };\n    let obj_key = this.evalInputObjID(obj);\n    this._positions[obj_key] = pos_obj;\n  }\n\n\n  /**\n   *\n   */\n  private getNodePosition(obj: any) : number {\n    let obj_key = this.evalInputObjID(obj);\n    // console.log(obj_key);\n\n    let occurrence : PositionHeapEntry = this._positions[obj_key];\n    // console.log(occurrence);\n    \n    return occurrence ? occurrence.position : null;\n  }\n\n\n  /**\n   * @param obj\n   * @returns {number}\n   */\n  private removeNodePosition(obj: any) : void {\n    let obj_key = this.evalInputObjID(obj);\n    delete this._positions[obj_key];\n  }\n\n\n}\n\n\nexport { BinaryHeap };","import {GraphMode, GraphStats, MinAdjacencyListDict} from '../core/interfaces';\nimport * as $N from '../core/base/BaseNode';\nimport * as $E from '../core/base/BaseEdge';\nimport * as $G from '../core/base/BaseGraph';\nimport * as $CB from '../utils/CallbackUtils';\nimport * as $BH from '../datastructs/BinaryHeap';\n\n\nexport const DEFAULT_WEIGHT: number = 1;\n\nexport interface PFS_Config {\n  result: { [id: string]: PFS_ResultEntry };\n  callbacks: PFS_Callbacks;\n  dir_mode: GraphMode;\n  goal_node: $N.IBaseNode;\n  messages?: PFS_Messages;\n  filters?: any;\n  evalPriority: any;\n  evalObjID: any;\n}\n\nexport interface PFS_ResultEntry {\n  distance: number; // evaluated by a\n  parent: $N.IBaseNode;\n  counter: number; // order of discovery\n}\n\nexport interface PFS_Callbacks {\n  init_pfs?: Array<Function>;\n  new_current?: Array<Function>;\n  not_encountered?: Array<Function>;\n  node_open?: Array<Function>;\n  node_closed?: Array<Function>;\n  better_path?: Array<Function>;\n  equal_path?: Array<Function>;\n  goal_reached?: Array<Function>;\n}\n\nexport interface PFS_Messages {\n  init_pfs_msgs?: Array<string>;\n  new_current_msgs?: Array<string>;\n  not_enc_msgs?: Array<string>;\n  node_open_msgs?: Array<string>;\n  node_closed_msgs?: Array<string>;\n  better_path_msgs?: Array<string>;\n  equal_path_msgs?: Array<string>;\n  goal_reached_msgs?: Array<string>;\n}\n\nexport interface PFS_Scope {\n  // OPEN is the heap we use for getting the best choice\n  OPEN_HEAP: $BH.BinaryHeap;\n  OPEN: { [id: string]: $N.NeighborEntry };\n  CLOSED: { [id: string]: $N.NeighborEntry };\n  nodes: { [id: string]: $N.IBaseNode };\n  root_node: $N.IBaseNode;\n  current: $N.NeighborEntry;\n  adj_nodes: Array<$N.NeighborEntry>;\n  next: $N.NeighborEntry;\n  proposed_dist: number;\n}\n\n/**\n * Priority first search\n * \n * Like BFS, we are not necessarily visiting the\n * whole graph, but only what's reachable from\n * a given start node.\n * \n * @param graph the graph to perform PFS only\n * @param v the node from which to start PFS\n * @param config a config object similar to that used\n * in BFS, automatically instantiated if not given..\n */\n\nfunction PFS(graph: $G.IGraph,\n              v: $N.IBaseNode,\n              config?: PFS_Config): { [id: string]: PFS_ResultEntry } {\n  config = config || preparePFSStandardConfig();\n  let callbacks = config.callbacks,\n    dir_mode = config.dir_mode,\n    evalPriority = config.evalPriority,\n    evalObjID = config.evalObjID;\n\n\n  /**\n\t * We are not traversing an empty graph...\n\t */\n  if (graph.getMode() === GraphMode.INIT) {\n    throw new Error('Cowardly refusing to traverse graph without edges.');\n  }\n  /**\n\t * We are not traversing a graph taking NO edges into account\n\t */\n  if (dir_mode === GraphMode.INIT) {\n    throw new Error('Cannot traverse a graph with dir_mode set to INIT.');\n  }\n\n\n  // Root NeighborEntries\n  let start_ne: $N.NeighborEntry = {\n    node: v,\n    edge: new $E.BaseEdge('virtual start edge', v, v, { weighted: true, weight: 0 }),\n    best: 0\n  };\n\n  let scope: PFS_Scope = {\n    OPEN_HEAP: new $BH.BinaryHeap($BH.BinaryHeapMode.MIN, evalPriority, evalObjID),\n    OPEN: {},\n    CLOSED: {},\n    nodes: graph.getNodes(),\n    root_node: v,\n    current: start_ne,\n    adj_nodes: [],\n    next: null,\n    proposed_dist: Number.POSITIVE_INFINITY,\n  };\n\n\n  /**\n\t * HOOK 1: PFS INIT\n\t */\n  callbacks.init_pfs && $CB.execCallbacks(callbacks.init_pfs, scope);\n  //initializes the result entry, gives the start node the final values, and default values for all others\n\n  scope.OPEN_HEAP.insert(start_ne);\n  scope.OPEN[start_ne.node.getID()] = start_ne;\n\n  /**\n   * Main loop\n   */\n  while (scope.OPEN_HEAP.size()) {\n    scope.current = scope.OPEN_HEAP.pop();\n    // console.log(`node: ${scope.current.node.getID()}`); //LOG!\n    // console.log(`best: ${scope.current.best}`); //LOG!\n\n\n    /**\n     * HOOK 2: NEW CURRENT\n     */\n    callbacks.new_current && $CB.execCallbacks(callbacks.new_current, scope);\n\n    if (scope.current == null) {\n      console.log(\"HEAP popped undefined - HEAP size: \" + scope.OPEN_HEAP.size());\n    }\n\n    // remove from OPEN\n    scope.OPEN[scope.current.node.getID()] = undefined;\n\n    // add it to CLOSED\n    scope.CLOSED[scope.current.node.getID()] = scope.current;\n\n    // TODO what if we already reached the goal?\n    if (scope.current.node === config.goal_node) {\n      /**\n       * HOOK 3: Goal node reached\n       */\n      config.callbacks.goal_reached && $CB.execCallbacks(config.callbacks.goal_reached, scope);\n\n      // If a goal node is set from the outside & we reach it, we stop.\n      return config.result;\n    }\n\n    /**\n     * Extend the current node, also called\n     * \"create n's successors\"...\n\t\t */\n\n    // TODO: Reverse callback logic to NOT merge anything by default!!!\n    if (dir_mode === GraphMode.MIXED) {\n      scope.adj_nodes = scope.current.node.reachNodes();\n    }\n    else if (dir_mode === GraphMode.UNDIRECTED) {\n      scope.adj_nodes = scope.current.node.connNodes();\n    }\n    else if (dir_mode === GraphMode.DIRECTED) {\n      scope.adj_nodes = scope.current.node.nextNodes();\n    }\n    else {\n      throw new Error('Unsupported traversal mode. Please use directed, undirected, or mixed');\n    }\n\n    /**\n     * EXPAND AND EXAMINE NEIGHBORHOOD\n     */\n\n    for (let adj_idx in scope.adj_nodes) {\n\n      scope.next = scope.adj_nodes[adj_idx];\n\n      // console.log(\"scopeNext now:\"); //LOG!\n      // console.log(scope.next.node.getID());\n\n      if (scope.CLOSED[scope.next.node.getID()]) {\n        /**\n         * HOOK 4: Goal node already closed\n         */\n        config.callbacks.node_closed && $CB.execCallbacks(config.callbacks.node_closed, scope);\n        continue;\n      }\n\n      if (scope.OPEN[scope.next.node.getID()]) {\n        // First let's recover the previous best solution from our OPEN structure,\n        // as the node's neighborhood-retrieving function cannot know it...\n        // console.log(\"MARKER - ALREADY OPEN\"); //LOG!\n        scope.next.best = scope.OPEN[scope.next.node.getID()].best;\n\n        /**\n         * HOOK 5: Goal node already visited, but not yet closed\n         */\n        config.callbacks.node_open && $CB.execCallbacks(config.callbacks.node_open, scope);\n\n        scope.proposed_dist = scope.current.best + (isNaN(scope.next.edge.getWeight()) ? DEFAULT_WEIGHT : scope.next.edge.getWeight());\n\n        /**\n         * HOOK 6: Better path found\n         */\n        if (scope.next.best > scope.proposed_dist) {\n          config.callbacks.better_path && $CB.execCallbacks(config.callbacks.better_path, scope);\n\n          // HEAP operations are necessary for internal traversal,\n          // so we handle them here in the main loop\n          // removing next with the old weight and re-adding it with updated value\n          scope.OPEN_HEAP.remove(scope.next);\n          // console.log(\"MARKER - BETTER DISTANCE\");\n          // console.log(scope.OPEN_HEAP);\n          scope.next.best = scope.proposed_dist;\n          scope.OPEN_HEAP.insert(scope.next);\n          scope.OPEN[scope.next.node.getID()].best = scope.proposed_dist;\n        }\n\n        /**\n         * HOOK 7: Equal path found (same weight)\n         */\n        //at the moment, this callback array is empty here in the PFS and in the Dijkstra, but used in the Johnsons\n\n        else if (scope.next.best === scope.proposed_dist) {\n          config.callbacks.equal_path && $CB.execCallbacks(config.callbacks.equal_path, scope);\n        }\n\n        continue;\n      }\n\n      // NODE NOT ENCOUNTERED\n      config.callbacks.not_encountered && $CB.execCallbacks(config.callbacks.not_encountered, scope);\n\n      // HEAP operations are necessary for internal traversal,\n      // so we handle them here in the main loop\n      scope.OPEN_HEAP.insert(scope.next);\n      scope.OPEN[scope.next.node.getID()] = scope.next;\n      // console.log(\"MARKER-NOT ENCOUNTERED\"); //LOG!\n    }\n\n  }\n\n  return config.result;\n}\n\n\nfunction preparePFSStandardConfig(): PFS_Config {\n  let config: PFS_Config = {\n    result: {},\n    callbacks: {\n      init_pfs: [],\n      new_current: [],\n      not_encountered: [],\n      node_open: [],\n      node_closed: [],\n      better_path: [],\n      equal_path: [],\n      goal_reached: []\n    },\n    messages: {\n      init_pfs_msgs: [],\n      new_current_msgs: [],\n      not_enc_msgs: [],\n      node_open_msgs: [],\n      node_closed_msgs: [],\n      better_path_msgs: [],\n      equal_path_msgs: [],\n      goal_reached_msgs: []\n    },\n    dir_mode: GraphMode.MIXED,\n    goal_node: null,\n    evalPriority: function (ne: $N.NeighborEntry) {\n      return ne.best || DEFAULT_WEIGHT;\n    },\n    evalObjID: function (ne: $N.NeighborEntry) {\n      return ne.node.getID();\n    }\n  };\n  \n  let callbacks = config.callbacks;\n\n  let count = 0;\n  let counter = function () {\n    return count++;\n  };\n\n  // Standard INIT callback\n  let initPFS = function (context: PFS_Scope) {\n    // initialize all nodes to infinite distance\n    for (let key in context.nodes) {\n      config.result[key] = {\n        distance: Number.POSITIVE_INFINITY,\n        parent: null,\n        counter: -1\n      };\n    }\n    // initialize root node entry\n    // maybe take heuristic into account right here...??\n    config.result[context.root_node.getID()] = {\n      distance: 0,\n      parent: context.root_node,\n      counter: counter()\n    };\n  };\n  callbacks.init_pfs.push(initPFS);\n\n\n  // Node not yet encountered callback\n  let notEncountered = function (context: PFS_Scope) {\n    // setting it's best score to actual distance + edge weight\n    // and update result structure\n    context.next.best = context.current.best + (isNaN(context.next.edge.getWeight()) ? DEFAULT_WEIGHT : context.next.edge.getWeight());\n\n    config.result[context.next.node.getID()] = {\n      distance: context.next.best,\n      parent: context.current.node,\n      counter: undefined\n    };\n  };\n  callbacks.not_encountered.push(notEncountered);\n\n\n  // Callback for when we find a better solution\n  let betterPathFound = function (context: PFS_Scope) {\n    config.result[context.next.node.getID()].distance = context.proposed_dist;\n    config.result[context.next.node.getID()].parent = context.current.node;\n  };\n  callbacks.better_path.push(betterPathFound);\n\n  return config;\n}\n\nexport { PFS, preparePFSStandardConfig };","import * as $G from '../core/base/BaseGraph';\nimport * as $E from '../core/base/BaseEdge';\nimport * as $N from '../core/base/BaseNode';\nimport { DEFAULT_WEIGHT } from \"./PFS\";\n\n\nexport interface BFArrrayResult {\n  distances: Array<number>;\n  neg_cycle: boolean;\n}\n\n\nexport interface BFDictResult {\n  distances: {};\n  neg_cycle: boolean;\n}\n\n\n/**\n * \n * @param graph \n * @param start \n */\nfunction BFSanityChecks(graph: $G.IGraph, start: $N.IBaseNode) {\n  if (graph == null || start == null) {\n    throw new Error('Graph as well as start node have to be valid objects.');\n  }\n  if (graph.nrDirEdges() === 0 && graph.nrUndEdges() === 0) {\n    throw new Error('Cowardly refusing to traverse a graph without edges.');\n  }\n  if (!graph.hasNodeID(start.getID())) {\n    throw new Error('Cannot start from an outside node.');\n  }\n}\n\n\nfunction BellmanFordArray(graph: $G.IGraph, start: $N.IBaseNode): BFArrrayResult {\n  BFSanityChecks(graph, start);\n\n  let distances: Array<number> = [],\n    nodes = graph.getNodes(),\n    edge: $E.IBaseEdge,\n    node_keys = Object.keys(nodes),\n    node: $N.IBaseNode,\n    id_idx_map: {} = {},\n    bf_edge_entry,\n    new_weight: number,\n    neg_cycle: boolean = false;\n\n\n  for (let n_idx = 0; n_idx < node_keys.length; ++n_idx) {\n    node = nodes[node_keys[n_idx]];\n    distances[n_idx] = (node === start) ? 0 : Number.POSITIVE_INFINITY;\n    id_idx_map[node.getID()] = n_idx;\n  }\n\n  // Initialize an edge array just holding the node indices, weight and directed\n  let graph_edges = graph.getDirEdgesArray().concat(graph.getUndEdgesArray());\n  let bf_edges = [];\n  for (let e_idx = 0; e_idx < graph_edges.length; ++e_idx) {\n    edge = graph_edges[e_idx];\n    let bf_edge_entry =\n      bf_edges.push([\n        id_idx_map[edge.getNodes().a.getID()],\n        id_idx_map[edge.getNodes().b.getID()],\n        isFinite(edge.getWeight()) ? edge.getWeight() : DEFAULT_WEIGHT,\n        edge.isDirected()\n      ]);\n  }\n\n  for (let i = 0; i < node_keys.length - 1; ++i) {\n    for (let e_idx = 0; e_idx < bf_edges.length; ++e_idx) {\n      edge = bf_edges[e_idx];\n      updateDist(edge[0], edge[1], edge[2]);\n      !edge[3] && updateDist(edge[1], edge[0], edge[2]);\n    }\n  }\n\n  for (let e_idx = 0; e_idx < bf_edges.length; ++e_idx) {\n    edge = bf_edges[e_idx];\n    if (betterDist(edge[0], edge[1], edge[2]) || (!edge[3] && betterDist(edge[1], edge[0], edge[2]))) {\n      neg_cycle = true;\n      break;\n    }\n  }\n\n  function updateDist(u, v, weight) {\n    new_weight = distances[u] + weight;\n    if (distances[v] > new_weight) {\n      distances[v] = new_weight;\n    }\n  }\n\n  function betterDist(u, v, weight) {\n    return (distances[v] > distances[u] + weight);\n  }\n\n  return { distances, neg_cycle };\n}\n\n\n\n/**\n * \n * @param graph \n * @param start \n */\nfunction BellmanFordDict(graph: $G.IGraph, start: $N.IBaseNode): BFDictResult {\n  BFSanityChecks(graph, start);\n\n  let distances = {},\n    edges: Array<$E.IBaseEdge>,\n    edge: $E.IBaseEdge,\n    a: string,\n    b: string,\n    weight: number,\n    new_weight: number,\n    nodes_size: number,\n    neg_cycle: boolean = false;\n\n  distances = {}; // Reset dists, TODO refactor\n  edges = graph.getDirEdgesArray().concat(graph.getUndEdgesArray());\n  nodes_size = graph.nrNodes();\n\n  for (let node in graph.getNodes()) {\n    distances[node] = Number.POSITIVE_INFINITY;\n  }\n  distances[start.getID()] = 0;\n\n  for (let i = 0; i < nodes_size - 1; ++i) {\n    for (let e_idx = 0; e_idx < edges.length; ++e_idx) {\n      edge = edges[e_idx];\n      a = edge.getNodes().a.getID();\n      b = edge.getNodes().b.getID();\n      weight = isFinite(edge.getWeight()) ? edge.getWeight() : DEFAULT_WEIGHT;\n      updateDist(a, b, weight);\n      !edge.isDirected() && updateDist(b, a, weight);\n    }\n  }\n\n  for (let edgeID in edges) {\n    edge = edges[edgeID];\n    a = edge.getNodes().a.getID();\n    b = edge.getNodes().b.getID();\n    weight = isFinite(edge.getWeight()) ? edge.getWeight() : DEFAULT_WEIGHT;\n    if (betterDist(a, b, weight) || (!edge.isDirected() && betterDist(b, a, weight))) {\n      neg_cycle = true;\n    }\n  }\n\n\n  function updateDist(u, v, weight) {\n    new_weight = distances[u] + weight;\n    if (distances[v] > new_weight) {\n      distances[v] = new_weight;\n    }\n  }\n\n  function betterDist(u, v, weight) {\n    return (distances[v] > distances[u] + weight);\n  }\n\n  return {distances, neg_cycle};\n}\n\n\n\nexport {\n  BellmanFordDict,\n  BellmanFordArray\n};","import {NextArray} from '../core/interfaces';\nimport * as $N from '../core/base/BaseNode';\nimport * as $G from '../core/base/BaseGraph';\nimport * as $PFS from '../traversal/PFS';\nimport * as $BF from '../traversal/BellmanFord';\nimport * as $SU from '../utils/StructUtils'\nimport {ComputeGraph} from \"../core/compute/ComputeGraph\";\n\n\nfunction Johnsons(graph: $G.IGraph): {} {\n\n  if (graph.nrDirEdges() === 0 && graph.nrUndEdges() === 0) {\n    throw new Error(\"Cowardly refusing to traverse graph without edges.\");\n  }\n\n  if (graph.hasNegativeEdge()) {\n    let extraNode: $N.IBaseNode = new $N.BaseNode(\"extraNode\");\n    graph = addExtraNandE(graph, extraNode);\n    let BFresult = $BF.BellmanFordDict(graph, extraNode);\n\n    //reminder: output of the BellmanFordDict is BFDictResult\n    //contains a dictionary called distances, format: {[nodeID]:dist}, and a boolean called neg_cycle\n    if (BFresult.neg_cycle) {\n      throw new Error(\"The graph contains a negative cycle, thus it can not be processed\");\n    }\n\n    else {\n      let newWeights: {} = BFresult.distances;\n\n      graph = reWeighGraph(graph, newWeights, extraNode);\n      //graph still has the extraNode\n      //reminder: deleteNode function removes its edges, too\n      graph.deleteNode(extraNode);\n      return PFSFromAllNodes(graph);\n    }\n  }\n\n  return PFSFromAllNodes(graph);\n}\n\n\n/**\n * \n * @param target \n * @param nodeToAdd \n * \n * @todo check if \n */\nfunction addExtraNandE(target: $G.IGraph, nodeToAdd: $N.IBaseNode): $G.IGraph {\n  let allNodes: { [key: string]: $N.IBaseNode } = target.getNodes();\n  target.addNode(nodeToAdd);\n  let tempCounter = 0;\n  //now add a directed edge from the extranode to all graph nodes, excluding itself\n  for (let nodeKey in allNodes) {\n    if (allNodes[nodeKey].getID() != nodeToAdd.getID()) {\n      target.addEdgeByNodeIDs(\"temp\" + tempCounter, nodeToAdd.getID(), allNodes[nodeKey].getID(),\n        { directed: true, weighted: true, weight: 0 });\n      tempCounter++;\n    }\n  }\n  return target;\n}\n\n\nfunction reWeighGraph(target: $G.IGraph, distDict: {}, tempNode: $N.IBaseNode): $G.IGraph {\n  //reminder: w(e)'=w(e)+dist(a)-dist(b), a and b the start and end nodes of the edge\n  let edges = target.getDirEdgesArray().concat(target.getUndEdgesArray());\n  for (let edge of edges) {\n    let a = edge.getNodes().a.getID();\n    let b = edge.getNodes().b.getID();\n\n    /**\n     * no need to re-weigh the temporary edges starting from the extraNode, they will be deleted anyway\n     * assuming that the node keys in the distDict correspond to the nodeIDs\n     */\n    if (a !== tempNode.getID() && edge.isWeighted) {\n      let oldWeight = edge.getWeight();\n      let newWeight = oldWeight + distDict[a] - distDict[b];\n      edge.setWeight(newWeight);\n    }\n    else {\n      let newWeight = $PFS.DEFAULT_WEIGHT + distDict[a] - distDict[b];\n      //collecting edgeID and directedness for later re-use\n      let edgeID: string = edge.getID();\n      let dirNess: boolean = edge.isDirected();\n\n      // one does not simply change an edge to being weighted\n      target.deleteEdge(edge);\n      target.addEdgeByNodeIDs(edgeID, a, b, { directed: dirNess, weighted: true, weight: newWeight });\n    }\n  }\n  return target;\n}\n\n\nfunction PFSFromAllNodes(graph: $G.IGraph): {} {\n  const cg = new ComputeGraph(graph);\n\n  let dists: Array<Array<number>> = cg.adjMatrixW();\n  let next: NextArray = cg.nextArray();\n\n  let nodesDict = graph.getNodes();\n  let nodeIDIdxMap = {};\n  let i = 0;\n  for (let key in nodesDict) {\n    nodeIDIdxMap[nodesDict[key].getID()] = i++;\n  }\n\n  let specialConfig: $PFS.PFS_Config = $PFS.preparePFSStandardConfig();\n\n  /**\n   * @todo should we just assume that edges at this point are all weighted?\n   */\n  let notEncounteredJohnsons = function (context: $PFS.PFS_Scope) {\n    context.next.best = context.current.best + context.next.edge.getWeight();\n    // context.current.best + (isNaN(context.next.edge.getWeight()) ? $PFS.DEFAULT_WEIGHT : context.next.edge.getWeight());\n\n    let i = nodeIDIdxMap[context.root_node.getID()],\n      j = nodeIDIdxMap[context.next.node.getID()];\n    if (context.current.node == context.root_node) {\n      dists[i][j] = context.next.best;\n      next[i][j][0] = j;\n    }\n    else {\n      dists[i][j] = context.next.best;\n      next[i][j][0] = nodeIDIdxMap[context.current.node.getID()];\n    }\n  };\n  specialConfig.callbacks.not_encountered.splice(0, 1, notEncounteredJohnsons);\n\n\n  let betterPathJohnsons = function (context: $PFS.PFS_Scope) {\n    let i = nodeIDIdxMap[context.root_node.getID()],\n      j = nodeIDIdxMap[context.next.node.getID()];\n\n    dists[i][j] = context.proposed_dist;\n\n    if (context.current.node !== context.root_node) {\n      next[i][j].splice(0, next[i][j].length, nodeIDIdxMap[context.current.node.getID()]);\n    }\n  };\n  specialConfig.callbacks.better_path.splice(0, 1, betterPathJohnsons);\n\n\n  let equalPathJohnsons = function (context: $PFS.PFS_Scope) {\n    let\n      i = nodeIDIdxMap[context.root_node.getID()],\n      j = nodeIDIdxMap[context.next.node.getID()];\n\n    if (context.current.node !== context.root_node) {\n      next[i][j] = $SU.mergeOrderedArraysNoDups(next[i][j], [nodeIDIdxMap[context.current.node.getID()]]);\n    }\n  };\n  specialConfig.callbacks.equal_path.push(equalPathJohnsons);\n\n\n  for (let key in nodesDict) {\n    $PFS.PFS(graph, nodesDict[key], specialConfig);\n  }\n\n  return [dists, next];\n}\n\n\nexport {\n  Johnsons, \n  addExtraNandE, \n  reWeighGraph, \n  PFSFromAllNodes\n};\n\n","import {\n\tDIR,\n\tGraphMode,\n\tGraphStats,\n\tNextArray,\n\tMinAdjacencyListArray,\n\tMinAdjacencyListDict\n} from '../interfaces';\nimport { IBaseNode, BaseNode } from './BaseNode';\nimport { BaseEdgeConfig, IBaseEdge, BaseEdge } from './BaseEdge';\nimport { prepareBFSStandardConfig, BFS, BFS_Scope } from '../../traversal/BFS';\nimport { DFS } from '../../traversal/DFS';\nimport { BellmanFordDict, BellmanFordArray } from '../../traversal/BellmanFord';\nimport { reWeighGraph, addExtraNandE } from '../../traversal/Johnsons';\nimport { TypedGraph } from \"../typed/TypedGraph\";\n\nconst DEFAULT_WEIGHT = 1;\n\n\nexport interface IGraph {\n\t/**\n\t * Getters\n\t */\n\treadonly label: string;\n\treadonly mode: GraphMode;\n\treadonly stats: GraphStats;\n\t// readonly adj_list: MinAdjacencyListArray;\n\n\t// ANALYSIS\n\tgetMode(): GraphMode;\n\tgetStats(): GraphStats;\n\n\t// HISTOGRAM\n\treadonly inHist: Set<number>[];\n\treadonly outHist: Set<number>[];\n\treadonly connHist: Set<number>[];\n\n\t// NODES\n\taddNode(node: IBaseNode): IBaseNode;\n\taddNodeByID(id: string, opts?: {}): IBaseNode;\n\thasNodeID(id: string): boolean;\n\tgetNodeById(id: string): IBaseNode;\n\tn(id: string): IBaseNode;\n\tgetNodes(): { [key: string]: IBaseNode };\n\tnrNodes(): number;\n\tgetRandomNode(): IBaseNode;\n\tdeleteNode(node): void;\n\n\t// EDGES\n\taddEdge(edge: IBaseEdge): IBaseEdge;\n\taddEdgeByID(label: string, node_a: IBaseNode, node_b: IBaseNode, opts?: {}): IBaseEdge;\n\taddEdgeByNodeIDs(label: string, node_a_id: string, node_b_id: string, opts?: {}): IBaseEdge;\n\thasEdgeID(id: string): boolean;\n\tgetEdgeById(id: string): IBaseEdge;\n\tgetDirEdgeByNodeIDs(node_a_id: string, node_b_id: string): IBaseEdge;\n\tgetUndEdgeByNodeIDs(node_a_id: string, node_b_id: string): IBaseEdge;\n\tgetDirEdges(): { [key: string]: IBaseEdge };\n\tgetUndEdges(): { [key: string]: IBaseEdge };\n\tgetDirEdgesArray(): Array<IBaseEdge>;\n\tgetUndEdgesArray(): Array<IBaseEdge>;\n\tnrDirEdges(): number;\n\tnrUndEdges(): number;\n\tdeleteEdge(edge: IBaseEdge): void;\n\tgetRandomDirEdge(): IBaseEdge;\n\tgetRandomUndEdge(): IBaseEdge;\n\n\t// NEGATIVE EDGES AND CYCLES\n\thasNegativeEdge(): boolean\n\thasNegativeCycles(node?: IBaseNode): boolean;\n\n\t// REINTERPRETING EDGES\n\ttoDirectedGraph(copy?): IGraph;\n\ttoUndirectedGraph(): IGraph;\n\n\t// PROPERTIES\n\tpickRandomProperty(propList): any;\n\tpickRandomProperties(propList, amount): Array<string>;\n\n\t// HANDLE ALL EDGES OF NODES\n\tdeleteInEdgesOf(node: IBaseNode): void;\n\tdeleteOutEdgesOf(node: IBaseNode): void;\n\tdeleteDirEdgesOf(node: IBaseNode): void;\n\tdeleteUndEdgesOf(node: IBaseNode): void;\n\tdeleteAllEdgesOf(node: IBaseNode): void;\n\n\t// HANDLE ALL EDGES IN GRAPH\n\tclearAllDirEdges(): void;\n\tclearAllUndEdges(): void;\n\tclearAllEdges(): void;\n\n\t// CLONING\n\tcloneStructure(): IGraph;\n\tcloneSubGraphStructure(start: IBaseNode, cutoff: Number): IGraph;\n\n\n\t// REWEIGHTING\n\treweighIfHasNegativeEdge(clone: boolean): IGraph;\n}\n\n\nclass BaseGraph implements IGraph {\n\tprotected _nr_nodes = 0;\n\tprotected _nr_dir_edges = 0;\n\tprotected _nr_und_edges = 0;\n\tprotected _mode: GraphMode = GraphMode.INIT;\n\tprotected _nodes: { [key: string]: IBaseNode } = {};\n\tprotected _dir_edges: { [key: string]: IBaseEdge } = {};\n\tprotected _und_edges: { [key: string]: IBaseEdge } = {};\n\n\tconstructor(protected _label) { }\n\n\tstatic isTyped(arg: any): arg is TypedGraph {\n\t\treturn !!arg.type;\n\t}\n\n\tget label(): string {\n\t\treturn this._label;\n\t}\n\n\tget mode(): GraphMode {\n\t\treturn this._mode;\n\t}\n\n\tget stats(): GraphStats {\n\t\treturn this.getStats();\n\t}\n\n\tget inHist(): Set<number>[] {\n\t\treturn this.degreeHist(DIR.in);\n\t}\n\n\tget outHist(): Set<number>[] {\n\t\treturn this.degreeHist(DIR.out);\n\t}\n\n\tget connHist(): Set<number>[] {\n\t\treturn this.degreeHist(DIR.und);\n\t}\n\n\tprivate degreeHist(dir: string): Set<number>[] {\n\t\tlet result = [];\n\t\tfor (let nid in this._nodes) {\n\t\t\tlet node = this._nodes[nid];\n\t\t\tlet deg;\n\t\t\tswitch (dir) {\n\t\t\t\tcase DIR.in:\n\t\t\t\t\tdeg = node.in_deg;\n\t\t\t\t\tbreak;\n\t\t\t\tcase DIR.out:\n\t\t\t\t\tdeg = node.out_deg;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tdeg = node.deg;\n\t\t\t}\n\t\t\tif (!result[deg]) {\n\t\t\t\tresult[deg] = new Set([node]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresult[deg].add(node);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * \n\t * @param clone \n\t * \n\t * @comment Convenience method -\n\t * Tests to be found in test suites for\n\t * BaseGraph, BellmanFord and Johnsons\n\t */\n\treweighIfHasNegativeEdge(clone: boolean = false): IGraph {\n\t\tif (this.hasNegativeEdge()) {\n\t\t\tlet result_graph: IGraph = clone ? this.cloneStructure() : this;\n\n\t\t\tlet extraNode: IBaseNode = new BaseNode(\"extraNode\");\n\t\t\tresult_graph = addExtraNandE(result_graph, extraNode);\n\t\t\tlet BFresult = BellmanFordDict(result_graph, extraNode);\n\n\t\t\tif (BFresult.neg_cycle) {\n\t\t\t\tthrow new Error(\"The graph contains a negative cycle, thus it can not be processed\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlet newWeights: {} = BFresult.distances;\n\n\t\t\t\tresult_graph = reWeighGraph(result_graph, newWeights, extraNode);\n\t\t\t\tresult_graph.deleteNode(extraNode);\n\t\t\t}\n\t\t\treturn result_graph;\n\t\t}\n\t}\n\n\n\t/**\n\t * Version 1: do it in-place (to the object you receive)\n\t * Version 2: clone the graph first, return the mutated clone\n\t */\n\ttoDirectedGraph(copy = false): IGraph {\n\t\tlet result_graph = copy ? this.cloneStructure() : this;\n\t\t// if graph has no edges, we want to throw an exception\n\t\tif (this._nr_dir_edges === 0 && this._nr_und_edges === 0) {\n\t\t\tthrow new Error(\"Cowardly refusing to re-interpret an empty graph.\")\n\t\t}\n\n\t\treturn result_graph;\n\t}\n\n\n\t/**\n\t * @todo implement!!!\n\t */\n\ttoUndirectedGraph(): IGraph {\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * what to do if some edges are not weighted at all?\n\t * Since graph traversal algortihms (and later maybe graphs themselves)\n\t * use default weights anyways, I am simply ignoring them for now...\n\t * @todo figure out how to test this...\n\t */\n\thasNegativeEdge(): boolean {\n\t\tlet has_neg_edge = false,\n\t\t\tedge: IBaseEdge;\n\n\t\t// negative und_edges are always negative cycles\n\n\t\tfor (let edge_id in this._und_edges) {\n\t\t\tedge = this._und_edges[edge_id];\n\t\t\tif (!edge.isWeighted()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (edge.getWeight() < 0) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tfor (let edge_id in this._dir_edges) {\n\t\t\tedge = this._dir_edges[edge_id];\n\t\t\tif (!edge.isWeighted()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (edge.getWeight() < 0) {\n\t\t\t\thas_neg_edge = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn has_neg_edge;\n\t}\n\n\n\t/**\n\t * Do we want to throw an error if an edge is unweighted?\n\t * Or shall we let the traversal algorithm deal with DEFAULT weights like now?\n\t */\n\thasNegativeCycles(node?: IBaseNode): boolean {\n\t\tif (!this.hasNegativeEdge()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tlet negative_cycle = false,\n\t\t\tstart = node ? node : this.getRandomNode();\n\n\t\t/**\n\t\t * Now do Bellman Ford over all graph components\n\t\t */\n\t\tDFS(this, start).forEach(comp => {\n\t\t\tlet min_count = Number.POSITIVE_INFINITY,\n\t\t\t\tcomp_start_node: string = \"\";\n\n\t\t\tObject.keys(comp).forEach(node_id => {\n\t\t\t\tif (min_count > comp[node_id].counter) {\n\t\t\t\t\tmin_count = comp[node_id].counter;\n\t\t\t\t\tcomp_start_node = node_id;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tif (BellmanFordArray(this, this._nodes[comp_start_node]).neg_cycle) {\n\t\t\t\tnegative_cycle = true;\n\t\t\t}\n\t\t});\n\n\t\treturn negative_cycle;\n\t}\n\n\n\tgetMode(): GraphMode {\n\t\treturn this._mode;\n\t}\n\n\n\tgetStats(): GraphStats {\n\t\treturn {\n\t\t\tmode: this._mode,\n\t\t\tnr_nodes: this._nr_nodes,\n\t\t\tnr_und_edges: this._nr_und_edges,\n\t\t\tnr_dir_edges: this._nr_dir_edges,\n\t\t\tdensity_dir: this._nr_dir_edges / (this._nr_nodes * (this._nr_nodes - 1)),\n\t\t\tdensity_und: 2 * this._nr_und_edges / (this._nr_nodes * (this._nr_nodes - 1))\n\t\t}\n\t}\n\n\tnrNodes(): number {\n\t\treturn this._nr_nodes;\n\t}\n\n\tnrDirEdges(): number {\n\t\treturn this._nr_dir_edges;\n\t}\n\n\tnrUndEdges(): number {\n\t\treturn this._nr_und_edges;\n\t}\n\n\t/**\n\t * \n\t * @param id \n\t * @param opts\n\t * \n\t * @todo addNode functions should check if a node with a given ID already exists -> node IDs have to be unique... \n\t */\n\taddNodeByID(id: string, opts?: {}): IBaseNode {\n\t\tif (this.hasNodeID(id)) {\n\t\t\tthrow new Error(\"Won't add node with duplicate ID.\");\n\t\t}\n\t\tlet node = new BaseNode(id, opts);\n\t\treturn this.addNode(node) ? node : null;\n\t}\n\n\taddNode(node: IBaseNode): IBaseNode {\n\t\tif (this.hasNodeID(node.getID())) {\n\t\t\tthrow new Error(\"Won't add node with duplicate ID.\");\n\t\t}\n\t\tthis._nodes[node.getID()] = node;\n\t\tthis._nr_nodes += 1;\n\t\treturn node;\n\t}\n\n\thasNodeID(id: string): boolean {\n\t\treturn !!this._nodes[id];\n\t}\n\n\tgetNodeById(id: string): IBaseNode {\n\t\treturn this._nodes[id];\n\t}\n\n\tn(id: string): IBaseNode {\n\t\treturn this.getNodeById(id);\n\t}\n\n\tgetNodes(): { [key: string]: IBaseNode } {\n\t\treturn this._nodes;\n\t}\n\n\t/**\n\t * CAUTION - This function takes linear time in # nodes\n\t */\n\tgetRandomNode(): IBaseNode {\n\t\treturn this.pickRandomProperty(this._nodes);\n\t}\n\n\tdeleteNode(node): void {\n\t\tlet rem_node = this._nodes[node.getID()];\n\t\tif (!rem_node) {\n\t\t\tthrow new Error('Cannot remove a foreign node.');\n\t\t}\n\t\t// Edges?\n\t\tlet in_deg = node.in_deg;\n\t\tlet out_deg = node.out_deg;\n\t\tlet deg = node.deg;\n\n\t\t// Delete all edges brutally...\n\t\tif (in_deg) {\n\t\t\tthis.deleteInEdgesOf(node);\n\t\t}\n\t\tif (out_deg) {\n\t\t\tthis.deleteOutEdgesOf(node);\n\t\t}\n\t\tif (deg) {\n\t\t\tthis.deleteUndEdgesOf(node);\n\t\t}\n\n\t\tdelete this._nodes[node.getID()];\n\t\tthis._nr_nodes -= 1;\n\t}\n\n\thasEdgeID(id: string): boolean {\n\t\treturn !!this._dir_edges[id] || !!this._und_edges[id];\n\t}\n\n\tgetEdgeById(id: string): IBaseEdge {\n\t\tlet edge = this._dir_edges[id] || this._und_edges[id];\n\t\tif (!edge) {\n\t\t\tthrow new Error(\"cannot retrieve edge with non-existing ID.\");\n\t\t}\n\t\treturn edge;\n\t}\n\n\tstatic checkExistanceOfEdgeNodes(node_a: IBaseNode, node_b: IBaseNode): void {\n\t\tif (!node_a) {\n\t\t\tthrow new Error(`Cannot find edge. Node A does not exist (in graph).`);\n\t\t}\n\t\tif (!node_b) {\n\t\t\tthrow new Error(\"Cannot find edge. Node B does not exist (in graph).\");\n\t\t}\n\t}\n\n\t// get the edge from node_a to node_b (or undirected)\n\tgetDirEdgeByNodeIDs(node_a_id: string, node_b_id: string) {\n\t\tconst node_a = this.getNodeById(node_a_id);\n\t\tconst node_b = this.getNodeById(node_b_id);\n\t\tBaseGraph.checkExistanceOfEdgeNodes(node_a, node_b);\n\n\t\t// check for outgoing directed edges\n\t\tlet edges_dir = node_a.outEdges(),\n\t\t\tedges_dir_keys = Object.keys(edges_dir);\n\n\t\tfor (let i = 0; i < edges_dir_keys.length; i++) {\n\t\t\tlet edge = edges_dir[edges_dir_keys[i]];\n\t\t\tif (edge.getNodes().b.getID() == node_b_id) {\n\t\t\t\treturn edge;\n\t\t\t}\n\t\t}\n\n\t\t// if we managed to arrive here, there is no edge!\n\t\tthrow new Error(`Cannot find edge. There is no edge between Node ${node_a_id} and ${node_b_id}.`);\n\t}\n\n\tgetUndEdgeByNodeIDs(node_a_id: string, node_b_id: string) {\n\t\tconst node_a = this.getNodeById(node_a_id);\n\t\tconst node_b = this.getNodeById(node_b_id);\n\t\tBaseGraph.checkExistanceOfEdgeNodes(node_a, node_b);\n\n\t\t// check for undirected edges\n\t\tlet edges_und = node_a.undEdges(),\n\t\t\tedges_und_keys = Object.keys(edges_und);\n\n\t\tfor (let i = 0; i < edges_und_keys.length; i++) {\n\t\t\tlet edge = edges_und[edges_und_keys[i]];\n\t\t\tlet b: string;\n\t\t\t(edge.getNodes().a.getID() == node_a_id) ? (b = edge.getNodes().b.getID()) : (b = edge.getNodes().a.getID());\n\t\t\tif (b == node_b_id) {\n\t\t\t\treturn edge;\n\t\t\t}\n\t\t}\n\t}\n\n\tgetDirEdges(): { [key: string]: IBaseEdge } {\n\t\treturn this._dir_edges;\n\t}\n\n\tgetUndEdges(): { [key: string]: IBaseEdge } {\n\t\treturn this._und_edges;\n\t}\n\n\tgetDirEdgesArray(): Array<IBaseEdge> {\n\t\tlet edges = [];\n\t\tfor (let e_id in this._dir_edges) {\n\t\t\tedges.push(this._dir_edges[e_id]);\n\t\t}\n\t\treturn edges;\n\t}\n\n\tgetUndEdgesArray(): Array<IBaseEdge> {\n\t\tlet edges = [];\n\t\tfor (let e_id in this._und_edges) {\n\t\t\tedges.push(this._und_edges[e_id]);\n\t\t}\n\t\treturn edges;\n\t}\n\n\taddEdgeByNodeIDs(label: string, node_a_id: string, node_b_id: string, opts?: {}): IBaseEdge {\n\t\tlet node_a = this.getNodeById(node_a_id),\n\t\t\tnode_b = this.getNodeById(node_b_id);\n\t\tif (!node_a) {\n\t\t\tthrow new Error(\"Cannot add edge. Node A does not exist\");\n\t\t}\n\t\telse if (!node_b) {\n\t\t\tthrow new Error(\"Cannot add edge. Node B does not exist\");\n\t\t}\n\t\telse {\n\t\t\treturn this.addEdgeByID(label, node_a, node_b, opts);\n\t\t}\n\t}\n\n\t/**\n\t * @description now all test cases pertaining addEdge() call this one...\n\t */\n\taddEdgeByID(id: string, node_a: IBaseNode, node_b: IBaseNode, opts?: BaseEdgeConfig): IBaseEdge {\n\t\tlet edge = new BaseEdge(id, node_a, node_b, opts || {});\n\t\treturn this.addEdge(edge) ? edge : null;\n\t}\n\n\t/**\n\t * @todo test cases should be reversed / completed\n\t * @todo make transactional\n\t */\n\taddEdge(edge: IBaseEdge): IBaseEdge {\n\t\tlet node_a = edge.getNodes().a,\n\t\t\tnode_b = edge.getNodes().b;\n\n\t\tif (!this.hasNodeID(node_a.getID()) || !this.hasNodeID(node_b.getID())\n\t\t\t|| this._nodes[node_a.getID()] !== node_a || this._nodes[node_b.getID()] !== node_b\n\t\t) {\n\t\t\tthrow new Error(\"can only add edge between two nodes existing in graph\");\n\t\t}\n\n\t\t// connect edge to first node anyways\n\t\tnode_a.addEdge(edge);\n\n\t\tif (edge.isDirected()) {\n\t\t\t// add edge to second node too\n\t\t\tnode_b.addEdge(edge);\n\t\t\tthis._dir_edges[edge.getID()] = edge;\n\t\t\tthis._nr_dir_edges += 1;\n\t\t\tthis.updateGraphMode();\n\t\t}\n\t\telse {\n\t\t\t// add edge to both nodes, except they are the same...\n\t\t\tif (node_a !== node_b) {\n\t\t\t\tnode_b.addEdge(edge);\n\t\t\t}\n\t\t\tthis._und_edges[edge.getID()] = edge;\n\t\t\tthis._nr_und_edges += 1;\n\t\t\tthis.updateGraphMode();\n\t\t}\n\t\treturn edge;\n\t}\n\n\tdeleteEdge(edge: IBaseEdge): void {\n\t\tlet dir_edge = this._dir_edges[edge.getID()];\n\t\tlet und_edge = this._und_edges[edge.getID()];\n\n\t\tif (!dir_edge && !und_edge) {\n\t\t\tthrow new Error('cannot remove non-existing edge.');\n\t\t}\n\n\t\tlet nodes = edge.getNodes();\n\t\tnodes.a.removeEdge(edge);\n\t\tif (nodes.a !== nodes.b) {\n\t\t\tnodes.b.removeEdge(edge);\n\t\t}\n\n\t\tif (dir_edge) {\n\t\t\tdelete this._dir_edges[edge.getID()];\n\t\t\tthis._nr_dir_edges -= 1;\n\t\t}\n\t\telse {\n\t\t\tdelete this._und_edges[edge.getID()];\n\t\t\tthis._nr_und_edges -= 1;\n\t\t}\n\n\t\tthis.updateGraphMode();\n\t}\n\n\t// Some atomicity / rollback feature would be nice here...\n\tdeleteInEdgesOf(node: IBaseNode): void {\n\t\tthis.checkConnectedNodeOrThrow(node);\n\t\tlet in_edges = node.inEdges();\n\t\tlet key: string,\n\t\t\tedge: IBaseEdge;\n\n\t\tfor (key in in_edges) {\n\t\t\tedge = in_edges[key];\n\t\t\tedge.getNodes().a.removeEdge(edge);\n\t\t\tdelete this._dir_edges[edge.getID()];\n\t\t\tthis._nr_dir_edges -= 1;\n\t\t}\n\t\tnode.clearInEdges();\n\t\tthis.updateGraphMode();\n\t}\n\n\t// Some atomicity / rollback feature would be nice here...\n\tdeleteOutEdgesOf(node: IBaseNode): void {\n\t\tthis.checkConnectedNodeOrThrow(node);\n\t\tlet out_edges = node.outEdges();\n\t\tlet key: string,\n\t\t\tedge: IBaseEdge;\n\n\t\tfor (key in out_edges) {\n\t\t\tedge = out_edges[key];\n\t\t\tedge.getNodes().b.removeEdge(edge);\n\t\t\tdelete this._dir_edges[edge.getID()];\n\t\t\tthis._nr_dir_edges -= 1;\n\t\t}\n\t\tnode.clearOutEdges();\n\t\tthis.updateGraphMode();\n\t}\n\n\t// Some atomicity / rollback feature would be nice here...\n\tdeleteDirEdgesOf(node: IBaseNode): void {\n\t\tthis.deleteInEdgesOf(node);\n\t\tthis.deleteOutEdgesOf(node);\n\t}\n\n\t// Some atomicity / rollback feature would be nice here...\n\tdeleteUndEdgesOf(node: IBaseNode): void {\n\t\tthis.checkConnectedNodeOrThrow(node);\n\t\tlet und_edges = node.undEdges();\n\t\tlet key: string,\n\t\t\tedge: IBaseEdge;\n\n\t\tfor (key in und_edges) {\n\t\t\tedge = und_edges[key];\n\t\t\tlet conns = edge.getNodes();\n\t\t\tconns.a.removeEdge(edge);\n\t\t\tif (conns.a !== conns.b) {\n\t\t\t\tconns.b.removeEdge(edge);\n\t\t\t}\n\t\t\tdelete this._und_edges[edge.getID()];\n\t\t\tthis._nr_und_edges -= 1;\n\t\t}\n\t\tnode.clearUndEdges();\n\t\tthis.updateGraphMode();\n\t}\n\n\t// Some atomicity / rollback feature would be nice here...\n\tdeleteAllEdgesOf(node: IBaseNode): void {\n\t\tthis.deleteDirEdgesOf(node);\n\t\tthis.deleteUndEdgesOf(node);\n\t}\n\n\t/**\n\t * Remove all the (un)directed edges in the graph\n\t */\n\tclearAllDirEdges(): void {\n\t\tfor (let edge in this._dir_edges) {\n\t\t\tthis.deleteEdge(this._dir_edges[edge]);\n\t\t}\n\t}\n\n\tclearAllUndEdges(): void {\n\t\tfor (let edge in this._und_edges) {\n\t\t\tthis.deleteEdge(this._und_edges[edge]);\n\t\t}\n\t}\n\n\tclearAllEdges(): void {\n\t\tthis.clearAllDirEdges();\n\t\tthis.clearAllUndEdges();\n\t}\n\n\n\t/**\n\t * CAUTION - This function is linear in # directed edges\n\t */\n\tgetRandomDirEdge(): IBaseEdge {\n\t\treturn this.pickRandomProperty(this._dir_edges);\n\t}\n\n\t/**\n\t * CAUTION - This function is linear in # undirected edges\n\t */\n\tgetRandomUndEdge(): IBaseEdge {\n\t\treturn this.pickRandomProperty(this._und_edges);\n\t}\n\n\n\tcloneStructure(): IGraph {\n\t\tlet new_graph = new BaseGraph(this._label),\n\t\t\told_nodes = this.getNodes(),\n\t\t\told_edge: IBaseEdge,\n\t\t\tnew_node_a = null,\n\t\t\tnew_node_b = null;\n\n\t\tfor ( let node_id in old_nodes ) {\n\t\t\tnew_graph.addNode(old_nodes[node_id].clone());\n\t\t}\n\n\t\t[this.getDirEdges(), this.getUndEdges()].forEach((old_edges) => {\n\t\t\tfor (let edge_id in old_edges) {\n\t\t\t\told_edge = old_edges[edge_id];\n\t\t\t\tnew_node_a = new_graph.getNodeById(old_edge.getNodes().a.getID());\n\t\t\t\tnew_node_b = new_graph.getNodeById(old_edge.getNodes().b.getID());\n\t\t\t\tnew_graph.addEdge(old_edge.clone(new_node_a, new_node_b))\n\t\t\t}\n\t\t});\n\n\t\treturn new_graph;\n\t}\n\n\tcloneSubGraphStructure(root: IBaseNode, cutoff: Number): IGraph {\n\t\tlet new_graph = new BaseGraph(this._label);\n\n\t\tlet config = prepareBFSStandardConfig();\n\n\t\tlet bfsNodeUnmarkedTestCallback = function (context: BFS_Scope) {\n\t\t\tif (config.result[context.next_node.getID()].counter > cutoff) {\n\t\t\t\tcontext.queue = [];\n\t\t\t} else { //This means we only add cutoff -1 nodes to the cloned graph, # of nodes is then equal to cutoff\n\t\t\t\tnew_graph.addNode(context.next_node.clone());\n\t\t\t}\n\t\t};\n\t\tconfig.callbacks.node_unmarked.push(bfsNodeUnmarkedTestCallback);\n\t\tBFS(this, root, config);\n\t\tlet old_edge: IBaseEdge,\n\t\t\tnew_node_a = null,\n\t\t\tnew_node_b = null;\n\n\t\t[this.getDirEdges(), this.getUndEdges()].forEach((old_edges) => {\n\t\t\tfor (let edge_id in old_edges) {\n\t\t\t\told_edge = old_edges[edge_id];\n\t\t\t\tnew_node_a = new_graph.getNodeById(old_edge.getNodes().a.getID());\n\t\t\t\tnew_node_b = new_graph.getNodeById(old_edge.getNodes().b.getID());\n\t\t\t\tif (new_node_a != null && new_node_b != null)\n\t\t\t\t\tnew_graph.addEdge(old_edge.clone(new_node_a, new_node_b));\n\t\t\t}\n\t\t});\n\n\t\treturn new_graph;\n\t}\n\n\n\tprotected checkConnectedNodeOrThrow(node: IBaseNode) {\n\t\tlet inGraphNode = this._nodes[node.getID()];\n\t\tif (!inGraphNode) {\n\t\t\tthrow new Error('Cowardly refusing to delete edges of a foreign node.');\n\t\t}\n\t}\n\n\n\tprotected updateGraphMode() {\n\t\tlet nr_dir = this._nr_dir_edges,\n\t\t\tnr_und = this._nr_und_edges;\n\n\t\tif (nr_dir && nr_und) {\n\t\t\tthis._mode = GraphMode.MIXED;\n\t\t}\n\t\telse if (nr_dir) {\n\t\t\tthis._mode = GraphMode.DIRECTED;\n\t\t}\n\t\telse if (nr_und) {\n\t\t\tthis._mode = GraphMode.UNDIRECTED;\n\t\t}\n\t\telse {\n\t\t\tthis._mode = GraphMode.INIT;\n\t\t}\n\t}\n\n\n\tpickRandomProperty(propList): any {\n\t\tlet tmpList = Object.keys(propList);\n\t\tlet randomPropertyName = tmpList[Math.floor(Math.random() * tmpList.length)];\n\t\treturn propList[randomPropertyName];\n\t}\n\n\n\t/**\n\t * In some cases we need to return a large number of objects\n\t * in one swoop, as calls to Object.keys() are really slow\n\t * for large input objects.\n\t *\n\t * In order to do this, we only extract the keys once and then\n\t * iterate over the key list and add them to a result array\n\t * with probability = amount / keys.length\n\t * \n\t * We also mark all used keys in case we haven't picked up\n\t * enough entities for the result array after the first round.\n\t * We then just fill up the rest of the result array linearly\n\t * with as many unused keys as necessary\n\t * \n\t * \n\t * @todo include generic Test Cases\n\t * @todo check if amount is larger than propList size\n\t * @todo This seems like a simple hack - filling up remaining objects\n\t * Could be replaced by a better fraction-increasing function above...\n\t * \n\t * @param propList\n\t * @param amount\n\t * @returns {Array}\n\t */\n\tpickRandomProperties(propList, amount): Array<string> {\n\t\tlet ids = [];\n\t\tlet keys = Object.keys(propList);\n\t\tlet fraction = amount / keys.length;\n\t\tlet used_keys = {};\n\n\t\tfor (let i = 0; ids.length < amount && i < keys.length; i++) {\n\t\t\tif (Math.random() < fraction) {\n\t\t\t\tids.push(keys[i]);\n\t\t\t\tused_keys[keys[i]] = i;\n\t\t\t}\n\t\t}\n\n\t\tlet diff = amount - ids.length;\n\t\tfor (let i = 0; i < keys.length && diff; i++) {\n\t\t\tif (used_keys[keys[i]] == null) {\n\t\t\t\tids.push(keys[i]);\n\t\t\t\tdiff--;\n\t\t\t}\n\t\t}\n\n\t\treturn ids;\n\t}\n\n}\n\nexport { BaseGraph };\n","import {BaseGraph} from '../core/base/BaseGraph'\nimport {BaseNode} from '../core/base/BaseNode';\nimport {BaseEdge} from '../core/base/BaseEdge';\n\n/**\n * Method to deep clone an object\n *\n * @param obj\n * @returns {*}\n *\n */\nfunction clone(obj: any): any {\n\tif (obj === null || typeof obj !== 'object') {\n\t\treturn obj;\n\t}\n\n\t/**\n\t * @description for the sake of cloning graph structures, we have specialized\n   *              clone methods within the BaseGraph, BaseNode & BaseEdge classes\n\t */\n\tif (obj instanceof BaseGraph || obj instanceof BaseNode || obj instanceof BaseEdge) {\n\t\treturn null;\n\t}\n\n\tlet cloneObj = Array.isArray(obj) ? [] : {};\n\tfor (let attribute in obj) {\n\t\tif ( !obj.hasOwnProperty(attribute) ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (typeof obj[attribute] === \"object\") {\n\t\t\tcloneObj[attribute] = clone(obj[attribute]);\n\t\t} else {\n\t\t\tcloneObj[attribute] = obj[attribute];\n\t\t}\n\t}\n\treturn cloneObj;\n}\n\n\n/**\n *\n * @param arr\n *\n * @todo it's obvious, nevertheless needs some testing...\n */\nfunction shuffleArray(arr: Array<any>): Array<any> {\n\tfor (let i = arr.length - 1; i >= 0; i--) {\n\n\t\tlet randomIndex = Math.floor(Math.random() * (i + 1));\n\t\tlet itemAtIndex = arr[randomIndex];\n\n\t\tarr[randomIndex] = arr[i];\n\t\tarr[i] = itemAtIndex;\n\t}\n\treturn arr;\n}\n\n\n/**\n * @args an Array of any kind of objects\n * @cb callback to return a unique identifier;\n * if this is duplicate, the object will not be stored in result.\n * @returns {Array}\n *\n * @todo\n */\nfunction mergeArrays(args: Array<Array<any>>, cb: Function = undefined) {\n\tfor (let arg_idx in args) {\n\t\tif (!Array.isArray(args[arg_idx])) {\n\t\t\tthrow new Error('Will only mergeArrays arrays');\n\t\t}\n\t}\n\n\tlet seen = {},\n\t\tresult = [],\n\t\tidentity;\n\n\tfor (let i = 0; i < args.length; i++) {\n\t\tfor (let j = 0; j < args[i].length; j++) {\n\t\t\tidentity = typeof cb !== 'undefined' ? cb(args[i][j]) : args[i][j];\n\n\t\t\tif (seen[identity] !== true) {\n\t\t\t\tresult.push(args[i][j]);\n\t\t\t\tseen[identity] = true;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n\n\n/**\n * Overwrites obj1's values with obj2's and adds obj2's if non existent in obj1\n * @param args Array of all the object to take keys from\n * @returns result object\n */\nfunction mergeObjects(args: Array<Object>) {\n\tfor (let i = 0; i < args.length; i++) {\n\t\tif (Object.prototype.toString.call(args[i]) !== '[object Object]') {\n\t\t\tthrow new Error('Will only take objects as inputs');\n\t\t}\n\t}\n\tlet result = {};\n\tfor (let i = 0; i < args.length; i++) {\n\t\tfor (let key in args[i]) {\n\t\t\tif (args[i].hasOwnProperty(key)) {\n\t\t\t\tresult[key] = args[i][key];\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n\n\n/**\n * Takes two ordered number arrays and merges them. The returned array is\n * also ordered and does not contain any duplicates.\n *\n * @param a: first array\n * @param b: second array\n */\nfunction mergeOrderedArraysNoDups(a: Array<number>, b: Array<number>): Array<number> {\n\tlet ret: Array<number> = [];\n\tlet idx_a = 0;\n\tlet idx_b = 0;\n\tif (a[0] != null && b[0] != null) {\n\t\twhile (true) {\n\t\t\tif (idx_a >= a.length || idx_b >= b.length) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (a[idx_a] == b[idx_b]) {\n\t\t\t\tif (ret[ret.length - 1] != a[idx_a]) {\n\t\t\t\t\tret.push(a[idx_a]);\n\t\t\t\t}\n\t\t\t\tidx_a++;\n\t\t\t\tidx_b++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (a[idx_a] < b[idx_b]) {\n\t\t\t\tret.push(a[idx_a]);\n\t\t\t\tidx_a++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (b[idx_b] < a[idx_a]) {\n\t\t\t\tret.push(b[idx_b]);\n\t\t\t\tidx_b++;\n\t\t\t}\n\t\t}\n\t}\n\twhile (idx_a < a.length) {\n\t\tif (a[idx_a] != null) {\n\t\t\tret.push(a[idx_a]);\n\t\t}\n\t\tidx_a++;\n\t}\n\twhile (idx_b < b.length) {\n\t\tif (b[idx_b] != null) {\n\t\t\tret.push(b[idx_b]);\n\t\t}\n\t\tidx_b++;\n\t}\n\treturn ret;\n}\n\n\nexport {\n\tclone,\n\tshuffleArray,\n\tmergeArrays,\n\tmergeObjects,\n\tmergeOrderedArraysNoDups\n};","import {TypedNode} from '../typed/TypedNode';\nimport * as $SU from '../../utils/StructUtils';\nimport {IBaseEdge} from \"./BaseEdge\";\n\n\nexport interface NeighborEntry {\n  node  : IBaseNode;\n  edge  : IBaseEdge;\n  // only used (and tested) in PFS\n  best? : number;\n}\n\nexport interface BaseNodeConfig {\n\tlabel?\t\t\t: string;\n\tfeatures?\t\t: {[key: string]: any};\n}\n\ntype NodeFeatures = { [k:string]: any };\n\n\nexport interface IBaseNode {\n\t// BASIC\n\treadonly id: string;\n\treadonly label: string;\n\treadonly features: NodeFeatures;\n\tsetLabel(label : string) : void;\n\n\t/**\n\t * @todo old method versions -> take out..\n\t */\n\tgetID()\t: string;\n\tgetLabel() : string;\n\t\n\t// FEATURES methods\n\tgetFeatures() : NodeFeatures;\n\tgetFeature(key: string) : any;\n\tf(key:string) : any | undefined; // shortcut for getFeature\n\tsetFeatures( features: NodeFeatures ) : void;\n\tsetFeature(key: string, value: any) : void;\n\tdeleteFeature(key: string) : any;\n\tclearFeatures() : void;\n\t\n\t// Degrees\n\treadonly deg: number;\n\treadonly in_deg: number;\n\treadonly out_deg: number;\n\treadonly self_deg: number;\n\treadonly self_in_deg: number;\n\treadonly self_out_deg: number;\n\t\n\t// EDGE methods\n\taddEdge(edge: IBaseEdge) : IBaseEdge;\n\thasEdge(edge: IBaseEdge) : boolean;\t\n\thasEdgeID(id: string) : boolean;\t\n\tgetEdge(id: string) : IBaseEdge;\n\n\tinEdges() : {[k: string] : IBaseEdge};\n\toutEdges() : {[k: string] : IBaseEdge};\n\tundEdges() : {[k: string] : IBaseEdge};\n\tdirEdges() : {[k: string] : IBaseEdge};\n\tallEdges() : {[k: string] : IBaseEdge};\n\n\tremoveEdge(edge: IBaseEdge) : void;\n\tremoveEdgeByID(id: string) : void;\n\t\n\t// Clear different types of edges\n\tclearOutEdges() : void;\n\tclearInEdges() : void;\n\tclearUndEdges() : void;\n\tclearEdges() : void;\n\t\n\t// neighborhood methods\n\tprevNodes() : Array<NeighborEntry>;\n\tnextNodes() : Array<NeighborEntry>;\n\tconnNodes() : Array<NeighborEntry>;\n\treachNodes(identityFunc?: Function) : Array<NeighborEntry>;\n\tallNeighbors(identityFunc?: Function) : Array<NeighborEntry>;\n\n\tclone() : IBaseNode;\n}\n\n\nclass BaseNode implements IBaseNode {\n\tprotected _label : string;\n\tprotected _in_deg = 0;\n\tprotected _out_deg = 0;\n\tprotected _deg = 0;\n\tprotected _self_in_deg = 0;\n\tprotected _self_out_deg = 0;\n\tprotected _self_deg = 0;\n\n\tprotected _features\t: NodeFeatures;\n\n\tprotected _in_edges\t\t: {[k: string] : IBaseEdge};\n\tprotected _out_edges\t: {[k: string] : IBaseEdge};\n\tprotected _und_edges\t: {[k: string] : IBaseEdge};\n\n\t/**\n\t * @param _id\n\t * @param config\n\t */\n\tconstructor (\n\t\t\t\t\t\t\t\tprotected _id: string,\n\t\t\t\t\t\t\t\tconfig: BaseNodeConfig = {}\n\t\t\t\t\t\t\t)\n\t{\n\t\tthis._in_edges = {};\n\t\tthis._out_edges = {};\n\t\tthis._und_edges = {};\n\t\tthis._label = config.label || _id;\n\t\tthis._features = config.features != null ? $SU.clone(config.features) : {};\n\t}\n\n\tstatic isTyped(arg: any): arg is TypedNode {\n\t\treturn !!arg.type;\n\t}\n\n\tget id(): string {\n\t\treturn this._id;\n\t}\n\n\tget label(): string {\n\t\treturn this._label;\n\t}\n\n\tget features(): NodeFeatures {\n\t\treturn this._features;\n\t}\n\t\n\tgetID()\t: string {\n\t\treturn this._id;\n\t}\n\t\n\tgetLabel() : string {\n\t\treturn this._label;\n\t}\n\n\tsetLabel(label : string) : void {\n\t\tthis._label = label;\n\t}\n\t\t\n\tgetFeatures() : { [k:string] : any } {\n\t\treturn this._features;\n\t}\n\t\n\tgetFeature(key: string) : any | undefined {\n\t\treturn this._features[key];\n\t}\n\n\tf(key:string) : any | undefined {\n\t\treturn this.getFeature(key);\n\t}\n\t\n\tsetFeatures( features: { [k:string]: any } ) : void {\n\t\tthis._features = $SU.clone(features);\n\t}\n\t\n\tsetFeature(key: string, value: any) : void {\n\t\tthis._features[key] = value;\n\t}\n\t\n\tdeleteFeature(key: string) : any {\n\t\tlet feat = this._features[key];\n\t\tdelete this._features[key];\n\t\treturn feat;\n\t}\n\t\n\tclearFeatures() : void {\n\t\tthis._features = {};\n\t}\n\n\tget deg() : number {\n\t\treturn this._deg;\n\t}\n\n\tget in_deg() : number {\n\t\treturn this._in_deg;\n\t}\n\n\tget out_deg() : number {\n\t\treturn this._out_deg;\n\t}\n\n\tget self_deg() : number {\n\t\treturn this._self_deg;\n\t}\n\n\tget self_in_deg() : number {\n\t\treturn this._self_in_deg;\n\t}\n\n\tget self_out_deg() : number {\n\t\treturn this._self_out_deg;\n\t}\n\n\t/**\n\t * We have to: \n\t * 1. throw an error if the edge is already attached\n\t * 2. add it to the edge array\n\t * 3. check type of edge (directed / undirected)\n\t * 4. update our degrees accordingly\n\t */\n\taddEdge(edge: IBaseEdge) : IBaseEdge {\n\t\tlet ends = edge.getNodes();\n\t\tif ( ends.a !== this && ends.b !== this ) {\n\t\t\tthrow new Error(\"Cannot add edge that does not connect to this node\");\n\t\t}\n\t\tconst id = edge.id;\n\n\t\tif ( edge.isDirected() ) {\n\t\t\t// is it outgoing or incoming?\n\t\t\tif ( ends.a === this && !this._out_edges[id]) {\n\t\t\t\tthis._out_edges[id] = edge;\n\t\t\t\tthis._out_deg += 1;\n\t\t\t\t// Directed self loop ?\n\t\t\t\tif ( ends.b === this && !this._in_edges[id]) {\n\t\t\t\t\tthis._in_edges[id] = edge;\n\t\t\t\t\tthis._in_deg += 1;\n\t\t\t\t\tthis._self_in_deg += 1;\n\t\t\t\t\tthis._self_out_deg += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// No self loop\n\t\t\telse if ( !this._in_edges[id] ) { // nodes.b === this\n\t\t\t\tthis._in_edges[id] = edge;\n\t\t\t\tthis._in_deg += 1;\n\t\t\t}\n\t\t}\n\t\t// UNdirected\n\t\telse {\n\t\t\tif (this._und_edges[ edge.id ]) {\n\t\t\t\tthrow new Error(\"Cannot add same undirected edge multiple times.\");\n\t\t\t}\n\t\t\tthis._und_edges[id] = edge;\n\t\t\tthis._deg += 1;\n\t\t\tif ( ends.a === ends.b ) {\n\t\t\t\tthis._self_deg += 1;\n\t\t\t}\n\t\t}\n\t\treturn edge;\n\t}\n\thasEdge(edge: IBaseEdge) : boolean {\n\t\treturn !!this._in_edges[ edge.getID() ] || !!this._out_edges[ edge.getID() ] || !!this._und_edges[ edge.getID() ];\n\t}\n\t\n\thasEdgeID(id: string) : boolean {\n\t\treturn !!this._in_edges[ id ] || !!this._out_edges[ id ] || !!this._und_edges[ id ];\n\t}\n\t\n\tgetEdge(id: string) : IBaseEdge {\n\t\tlet edge = this._in_edges[id] || this._out_edges[id] || this._und_edges[id];\n\t\tif ( !edge ) {\n\t\t\tthrow new Error(\"Cannot retrieve non-existing edge.\");\n\t\t}\n\t\treturn edge;\n\t}\n\t\n\tinEdges() : {[k: string] : IBaseEdge} {\n\t\treturn this._in_edges;\n\t}\n\t\n\toutEdges() : {[k: string] : IBaseEdge} {\n\t\treturn this._out_edges;\n\t}\n\t\n\tundEdges() : {[k: string] : IBaseEdge} {\n\t\treturn this._und_edges;\n\t}\n\n\tdirEdges() : {[k: string] : IBaseEdge} {\n\t\treturn $SU.mergeObjects([this._in_edges, this._out_edges]);\n\t}\n\n\tallEdges() : {[k: string] : IBaseEdge} {\n\t\treturn $SU.mergeObjects([this._in_edges, this._out_edges, this._und_edges]);\n\t}\n\n\t/**\n\t * @description automatically takes care of self-loops (since looking up in all internal data structures)\n\t * @param edge\n\t */\n\tremoveEdge(edge: IBaseEdge) : void {\n\t\tif ( !this.hasEdge(edge) ) {\n\t\t\tthrow new Error(\"Cannot remove unconnected edge.\");\n\t\t}\n\t\tconst id = edge.id;\n\t\tconst ends = edge.getNodes();\n\t\tlet e = this._und_edges[id];\n\t\tif ( e ) {\n\t\t\tdelete this._und_edges[id];\n\t\t\tthis._deg -= 1;\n\t\t\t( ends.a === ends.b ) && ( this._self_deg -= 1 );\n\t\t}\n\t\te = this._in_edges[id];\n\t\tif ( e ) {\n\t\t\tdelete this._in_edges[id];\n\t\t\tthis._in_deg -= 1;\n\t\t\t( ends.a === ends.b ) && ( this._self_in_deg -= 1 );\n\t\t}\n\t\te = this._out_edges[id];\n\t\tif ( e ) {\n\t\t\tdelete this._out_edges[id];\n\t\t\tthis._out_deg -= 1;\n\t\t\t( ends.a === ends.b ) && ( this._self_out_deg -= 1 );\n\t\t}\n\t}\n\n\tremoveEdgeByID(id: string) : void {\n\t\tif ( !this.hasEdgeID(id) ) {\n\t\t\tthrow new Error(\"Cannot remove unconnected edge.\");\n\t\t}\n\t\tthis.removeEdge(this.getEdge(id));\n\t}\n\n\t/**\n\t * @description slow -> if possible, just clear ALL edges instead\n\t */\n\tclearOutEdges() : void {\n\t\tfor ( let e of Object.values(this.outEdges()) ) {\n\t\t\tthis.removeEdge(e);\n\t\t}\n\t}\n\n\t/**\n\t * @description slow -> if possible, just clear ALL edges instead\n\t */\n\tclearInEdges() : void {\n\t\tfor ( let e of Object.values(this.inEdges()) ) {\n\t\t\tthis.removeEdge(e);\n\t\t}\n\t}\n\n\tclearUndEdges() : void {\n\t\tthis._und_edges = {};\n\t\tthis._deg = 0;\n\t\tthis._self_deg = 0;\n\t}\n\t\n\tclearEdges() : void {\n\t\tthis.clearUndEdges();\n\t\tthis._in_edges = {};\n\t\tthis._out_edges = {};\n\t\tthis._deg = this._self_deg = this._in_deg = this._self_in_deg = this._out_deg = this._self_out_deg = 0;\n\t}\n\t\n\t/**\n\t * return the set of all nodes that have\n\t * directed edges coming into this node\n\t */\n\tprevNodes() : Array<NeighborEntry> {\n\t\tlet prevs : Array<NeighborEntry> = [];\n\t\tlet key \t: string,\n\t\t\t\tedge \t: IBaseEdge;\n\t\t\t\t\n\t\tfor ( key in this._in_edges ) {\n\t\t\tif ( this._in_edges.hasOwnProperty(key) ) {\n        edge = this._in_edges[key];\n\t\t\t\tprevs.push({\n          node: edge.getNodes().a,\n          edge: edge\n        });\n\t\t\t}\n\t\t}\t\t\n\t\treturn prevs;\n\t}\n\t\n\t/**\n\t * return the set of all nodes that have\n\t * directed edges going out from this node\n\t */\n\tnextNodes() : Array<NeighborEntry> {\n\t\tlet nexts : Array<NeighborEntry> = [];\n\t\tlet key \t: string,\n\t\t\t\tedge \t: IBaseEdge;\n\t\t\n\t\tfor ( key in this._out_edges ) {\n\t\t\tif ( this._out_edges.hasOwnProperty(key) ) {\n        edge = this._out_edges[key];\n\t\t\t\tnexts.push({\n          node: edge.getNodes().b,\n          edge: edge\n        });\n\t\t\t}\n\t\t}\n\t\treturn nexts;\n\t}\n\t\n\t/**\n\t * return the set of all nodes that are\n\t * connected to this node via undirected edges\n\t */\n\tconnNodes() : Array<NeighborEntry> {\n\t\tlet conns : Array<NeighborEntry> = [];\n\t\tlet key \t: string,\n\t\t\t\tedge \t: IBaseEdge;\n\t\t\n\t\tfor ( key in this._und_edges ) {\n\t\t\tif ( this._und_edges.hasOwnProperty(key) ) {\n        edge = this._und_edges[key];\n\t\t\t\tlet nodes = edge.getNodes();\n\t\t\t\tif ( nodes.a === this ) {\n\t\t\t\t\tconns.push({\n            node: edge.getNodes().b,\n            edge: edge\n          });\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tconns.push({\n            node: edge.getNodes().a,\n            edge: edge\n          });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn conns;\n\t}\n\n\n\t/**\n\t * return the set of all nodes 'reachable' from this node,\n\t * either via unconnected or outgoing edges\n\t *\n\t * @param identityFunc can be used to remove 'duplicates' from resulting array,\n\t * if necessary\n\t * @returns {Array}\n\t *\n   */\n\treachNodes(identityFunc?: Function) : Array<NeighborEntry> {\n\t\tlet identity = 0;\n    return $SU.mergeArrays(\n\t\t\t[ this.nextNodes(), this.connNodes() ],\n\t\t\tidentityFunc || ( ne => identity++ )\n\t\t);\n\t}\n\n\n\t/**\n\t * return the set of all nodes connected to this node\n\t *\n\t * @param identityFunc can be used to remove 'duplicates' from resulting array,\n\t * if necessary\n\t * @returns {Array}\n\t *\n   */\n\tallNeighbors(identityFunc?: Function) : Array<NeighborEntry> {\n\t\tlet identity = 0;\n\t\t// console.log(this.nextNodes());\n    return $SU.mergeArrays([this.prevNodes(), this.nextNodes(), this.connNodes()],\n\t\t\tidentityFunc || function(ne) {return identity++});\n\t}\n\n\n\tclone() : IBaseNode {\n\t\tlet new_node = new BaseNode(this._id);\n\t\tnew_node._label = this._label;\n\t\tnew_node.setFeatures( $SU.clone( this.getFeatures() ) );\n\t\treturn new_node;\n\t}\n\t\n}\n\nexport { BaseNode };\n","import * as $N from \"./BaseNode\";\nimport { TypedEdge } from '../typed/TypedEdge';\nimport * as $SU from \"../../utils/StructUtils\";\n\nexport interface IConnectedNodes {\n\ta: $N.IBaseNode;\n\tb: $N.IBaseNode;\n}\n\nexport type EdgeFeatures = { [k:string]: any };\n\n/**\n * Edges are the most basic components in graphinius.\n * They control no other elements below them, but hold\n * references to the nodes they are connecting...\n * @param _id internal id, public\n * @param _label edge label, public\n */\nexport interface IBaseEdge {\n\t/**\n\t * Getters\n\t */\n\treadonly id: string;\n\treadonly label: string;\n\treadonly features: EdgeFeatures;\n\n\tgetID() : string;\n\tgetLabel() : string;\n\tsetLabel(label : string) : void;\n\n\t// FEATURES methods\n\tgetFeatures() : EdgeFeatures;\n\tgetFeature(key: string) : any;\n\tf(key:string) : any | undefined; // shortcut for getFeature\n\tsetFeatures( features: EdgeFeatures ) : void;\n\tsetFeature(key: string, value: any) : void;\n\tdeleteFeature(key: string) : any;\n\tclearFeatures() : void;\n\n\tisDirected()\t\t\t\t\t\t: boolean;\n\tisWeighted()\t\t\t\t\t\t: boolean;\n\tgetWeight()\t\t\t\t\t\t\t: number; // Exception if not weighted\n\tsetWeight(w:number) \t\t: void; // Exception if not weighted\n\n\tgetNodes()\t: IConnectedNodes;\n\n\tclone(node_a : $N.BaseNode, node_b : $N.BaseNode) : IBaseEdge;\n\n\t/**\n\t * An edge should either be directed or not, weighted or not.\n\t * Changing those properties on live edges is not allowed,\n\t * rather delete the edge and construct a new one altogether\n\t */\n\t// setDirected(d:boolean)\t: void;\n\t// setWeighted(w:boolean)\t: void;\n}\n\nexport interface BaseEdgeConfig {\n\tdirected?\t\t: boolean;\n\tweighted?\t\t: boolean;\n\tweight?\t\t\t: number;\n\tlabel?\t\t\t: string;\n\tfeatures?\t\t: EdgeFeatures;\n}\n\nclass BaseEdge implements IBaseEdge {\n\tprotected _directed\t\t: boolean;\n\tprotected _weighted \t: boolean;\n\tprotected _weight\t\t\t: number;\n\tprotected _label\t\t\t: string;\n\tprotected _features\t\t: EdgeFeatures;\n\n\tconstructor (protected _id: string,\n\t\t\t\t\t\t\tprotected _node_a: $N.IBaseNode,\n\t\t\t\t\t\t\tprotected _node_b: $N.IBaseNode,\n\t\t\t\t\t\t\tconfig?: BaseEdgeConfig)\n\t\t{\n\t\t\tif( !( _node_a instanceof $N.BaseNode ) || !( _node_b instanceof $N.BaseNode ) ) {\n\t\t\t\tthrow new Error(\"cannot instantiate edge without two valid node objects\");\n\t\t}\n\n\t\tconfig = config || {};\n\t\tthis._directed = config.directed || false;\n\t\tthis._weighted = config.weighted || false;\n    // @NOTE isNaN and Number.isNaN confusion...\n\t\tthis._weight = this._weighted ? ( isNaN(config.weight) ? 1 : config.weight ) : undefined;\n\t\tthis._label = config.label || this._id;\n\t\tthis._features = config.features != null ? $SU.clone(config.features) : {};\n\t}\n\n\tget id(): string {\n\t\treturn this._id;\n\t}\n\n\tget label(): string {\n\t\treturn this._label;\n\t}\n\n\tget features(): EdgeFeatures {\n\t\treturn this._features;\n\t}\n\n\tgetID() : string {\n\t\treturn this._id;\n\t}\n\n\tgetLabel() : string {\n\t\treturn this._label;\n\t}\n\n\tsetLabel(label : string) : void {\n\t\tthis._label = label;\n\t}\n\n\tgetFeatures() : { [k:string] : any } {\n\t\treturn this._features;\n\t}\n\n\tgetFeature(key: string) : any | undefined {\n\t\treturn this._features[key];\n\t}\n\n\tf(key:string) : any | undefined {\n\t\treturn this.getFeature(key);\n\t}\n\n\tsetFeatures( features: { [k:string]: any } ) : void {\n\t\tthis._features = $SU.clone(features);\n\t}\n\n\tsetFeature(key: string, value: any) : void {\n\t\tthis._features[key] = value;\n\t}\n\n\tdeleteFeature(key: string) : any {\n\t\tlet feat = this._features[key];\n\t\tdelete this._features[key];\n\t\treturn feat;\n\t}\n\n\tclearFeatures() : void {\n\t\tthis._features = {};\n\t}\n\n\tisDirected () : boolean {\n\t\treturn this._directed;\n\t}\n\n\tisWeighted () : boolean {\n\t\treturn this._weighted;\n\t}\n\n\tgetWeight() : number {\n\t\treturn this._weight;\n\t}\n\n\tsetWeight(w:number) : void {\n\t\tif ( !this._weighted ) {\n\t\t\tthrow new Error(\"Cannot set weight on unweighted edge.\");\n\t\t}\n\t\tthis._weight = w;\n\t}\n\n\tgetNodes() : IConnectedNodes {\n\t\treturn {a: this._node_a, b: this._node_b};\n\t}\n\n\tclone(new_node_a : $N.BaseNode, new_node_b : $N.BaseNode) : BaseEdge {\n\t\tif( !( new_node_a instanceof $N.BaseNode ) || !( new_node_b instanceof $N.BaseNode ) ) {\n\t\t\tthrow new Error(\"refusing to clone edge if any new node is invalid\");\n\t\t}\n\n\t\treturn new BaseEdge(\n\t\t\tthis._id,\n\t\t\tnew_node_a,\n\t\t\tnew_node_b,\n\t\t\t{\n\t\t\t\tdirected\t: this._directed,\n\t\t\t\tweighted\t: this._weighted,\n\t\t\t\tweight\t\t: this._weight,\n\t\t\t\tlabel\t\t\t: this._label\n\t\t\t}\n\t\t);\n\t}\n\n\tstatic isTyped(arg: any): arg is TypedEdge {\n\t\treturn !!arg.type;\n\t}\n}\n\nexport { BaseEdge };\n","import { IBaseEdge, BaseEdge, BaseEdgeConfig } from '../base/BaseEdge';\nimport { GENERIC_TYPES } from '../../config/run_config';\nimport * as $N from \"../base/BaseNode\";\n\n\nexport interface ITypedEdge extends IBaseEdge {\n\treadonly type: string;\n}\n\n\nexport interface TypedEdgeConfig extends BaseEdgeConfig {\n\ttype?: string;\n}\n\n\nclass TypedEdge extends BaseEdge implements ITypedEdge {\n\tprotected _type : string;\n\n\tconstructor(protected _id: string,\n\t\t\t\t\t\t\tprotected _node_a: $N.IBaseNode,\n\t\t\t\t\t\t\tprotected _node_b: $N.IBaseNode,\n\t\t\t\t\t\t\tconfig: TypedEdgeConfig = {}) {\n\t\tsuper(_id, _node_a, _node_b, config);\n\t\tthis._type = config.type || GENERIC_TYPES.Edge;\n\t}\n\n\tget type() {\n\t\treturn this._type;\n\t}\n\n}\n\n\nexport {\n\tTypedEdge\n}","import {IBaseNode, BaseNode, BaseNodeConfig} from '../base/BaseNode';\nimport {ITypedEdge, TypedEdge} from \"./TypedEdge\";\nimport {GENERIC_TYPES} from \"../../config/run_config\";\n\n\nexport interface TypedNeighborEntry {\n\tn: ITypedNode;\n\te: string; // edge entry\n\tw: number; // weight\n}\n\nexport interface TypedAdjListsEntry {\n\tins?: Set<string>;\n\touts?: Set<string>;\n\tconns?: Set<string>;\n}\n\nexport type TypedAdjSets = { [type: string]: TypedAdjListsEntry };\n\n\nexport interface TypedEdgesStatsEntry {\n\tins: number;\n\touts: number;\n\tconns: number;\n}\n\nexport interface TypedNodeStats {\n\ttyped_edges: { [key: string]: TypedEdgesStatsEntry };\n}\n\n\nexport interface ITypedNode extends IBaseNode {\n\treadonly type: string;\n\n\treadonly stats: TypedNodeStats;\n\n\tuniqueNID(e: ITypedEdge): string;\n\n\taddEdge(edge: ITypedEdge): ITypedEdge;\n\n\tremoveEdge(edge: ITypedEdge): void;\n\n\t// removeEdgeByID(id: string): void;\n\n\t/**\n\t * Typed neighbor methods\n\t * @param type string identifying the edge type\n\t * @todo also restructure BaseNode names for clarity?\n\t */\n\tins(type: string): Set<string>;\n\n\touts(type: string): Set<string>;\n\n\tunds(type: string): Set<string>;\n}\n\n\nexport interface TypedNodeConfig extends BaseNodeConfig {\n\ttype?: string;\n}\n\n\nclass TypedNode extends BaseNode implements ITypedNode {\n\tprotected _type: string;\n\tprotected _typedAdjSets: TypedAdjSets;\n\n\tconstructor(protected _id: string, config: TypedNodeConfig = {}) {\n\t\tsuper(_id, config);\n\t\tthis._type = config.type || GENERIC_TYPES.Node;\n\t\tthis._typedAdjSets = {\n\t\t\t[GENERIC_TYPES.Edge]: {\n\t\t\t\tins: new Set<string>(),\n\t\t\t\touts: new Set<string>(),\n\t\t\t\tconns: new Set<string>()\n\t\t\t}\n\t\t}\n\t}\n\n\n\tget type(): string {\n\t\treturn this._type;\n\t}\n\n\n\tget stats(): TypedNodeStats {\n\t\tconst result: TypedNodeStats = {\n\t\t\ttyped_edges: {}\n\t\t};\n\t\tfor ( let type of Object.keys(this._typedAdjSets) ) {\n\t\t\tresult.typed_edges[type] = {ins: 0, outs: 0, conns: 0};\n\t\t\tresult.typed_edges[type].ins = this._typedAdjSets[type].ins ? this._typedAdjSets[type].ins.size : 0;\n\t\t\tresult.typed_edges[type].outs = this._typedAdjSets[type].outs ? this._typedAdjSets[type].outs.size : 0;\n\t\t\tresult.typed_edges[type].conns = this._typedAdjSets[type].conns ? this._typedAdjSets[type].conns.size : 0;\n\t\t}\n\t\treturn result;\n\t}\n\n\n\taddEdge(edge: ITypedEdge): ITypedEdge {\n\t\tif (!super.addEdge(edge)) {\n\t\t\treturn null;\n\t\t}\n\t\tconst type = edge.type || GENERIC_TYPES.Edge;\n\t\tconst dir = edge.isDirected();\n\t\tconst uid = this.uniqueNID(edge);\n\n\t\tif ( !this._typedAdjSets[type] ) {\n\t\t\tthis._typedAdjSets[type] = {}\n\t\t}\n\t\tif ( !dir ) {\n\t\t\tif ( !this._typedAdjSets[type].conns ) {\n\t\t\t\tthis._typedAdjSets[type].conns = new Set<string>();\n\t\t\t}\n\t\t\tthis._typedAdjSets[type].conns.add(uid);\n\t\t}\n\t\telse if ( edge.getNodes().a === this ) {\n\t\t\tif ( !this._typedAdjSets[type].outs ) {\n\t\t\t\tthis._typedAdjSets[type].outs = new Set<string>();\n\t\t\t}\n\t\t\tthis._typedAdjSets[type].outs.add(uid);\n\t\t}\n\t\telse {\n\t\t\tif ( !this._typedAdjSets[type].ins ) {\n\t\t\t\tthis._typedAdjSets[type].ins = new Set<string>();\n\t\t\t}\n\t\t\tthis._typedAdjSets[type].ins.add(uid);\n\t\t}\n\n\t\t// logger.log(this._typedAdjSets);\n\t\treturn edge;\n\t}\n\n\n\t/**\n\t * @description we assume\n\t * \t\t\t\t\t\t\t- type is present if super removes edge without throwing\n\t * @param edge\n\t */\n\tremoveEdge(edge: ITypedEdge): void {\n\t\t// Throws when something happens...\n\t\tsuper.removeEdge(edge);\n\n\t\tconst type = edge.type || GENERIC_TYPES.Edge;\n\t\tconst dir = edge.isDirected();\n\t\tconst uid = this.uniqueNID(edge);\n\n\t\tif ( !dir ) {\n\t\t\tthis._typedAdjSets[type].conns.delete(uid);\n\t\t}\n\t\telse if ( edge.getNodes().a === this ) {\n\t\t\tthis._typedAdjSets[type].outs.delete(uid);\n\t\t}\n\t\telse {\n\t\t\tthis._typedAdjSets[type].ins.delete(uid);\n\t\t}\n\t\tif ( type !== GENERIC_TYPES.Edge && this.noEdgesOfTypeLeft(type) ) {\n\t\t\tdelete this._typedAdjSets[type];\n\t\t}\n\t}\n\n\n\t// removeEdgeByID(id: string): void {\n\t// \tsuper.removeEdgeByID(id);\n\t// }\n\n\n\tins(type: string): Set<string> {\n\t\treturn this._typedAdjSets[type] ? this._typedAdjSets[type].ins : undefined;\n\t}\n\n\n\touts(type: string): Set<string> {\n\t\treturn this._typedAdjSets[type] ? this._typedAdjSets[type].outs : undefined;\n\t}\n\n\n\tunds(type: string): Set<string> {\n\t\treturn this._typedAdjSets[type] ? this._typedAdjSets[type].conns : undefined;\n\t}\n\n\n\tall(type:string): Set<string> {\n\t\tconst result = new Set<any>(); // spread operator has a problem with Set<string>...\n\t\tif ( this._typedAdjSets[type] ) {\n\t\t\tthis._typedAdjSets[type].ins && result.add([...this._typedAdjSets[type].ins]);\n\t\t\tthis._typedAdjSets[type].outs && result.add([...this._typedAdjSets[type].outs]);\n\t\t\tthis._typedAdjSets[type].conns && result.add([...this._typedAdjSets[type].conns]);\n\t\t}\n\t\treturn result;\n\t}\n\n\n\t/**\n\t * Unique ID for Neighbor (traversal)\n\t * @param e ITypedEdge\n\t * @description {node} `other / target` node\n\t * @returns unique neighbor entry ID\n\t */\n\tuniqueNID(e: ITypedEdge): string {\n\t\tconst {a, b} = e.getNodes();\n\t\tconst node = a === this ? b : a;\n\t\tlet string = `${node.id}#${e.id}#`;\n\t\tstring += e.isWeighted() ? 'w#' + e.getWeight() : 'u';\n\t\treturn string;\n\t}\n\n\n\tstatic nIDFromUID(uid: string) {\n\t\treturn uid.split('#')[0];\n\t}\n\n\n\tprivate noEdgesOfTypeLeft(type: string): boolean {\n\t\treturn (!this._typedAdjSets[type].ins || !this._typedAdjSets[type].ins.size)\n\t\t\t&& (!this._typedAdjSets[type].outs || !this._typedAdjSets[type].outs.size)\n\t\t\t&& (!this._typedAdjSets[type].conns || !this._typedAdjSets[type].conns.size);\n\t}\n\n}\n\n\nexport {\n\tTypedNode\n}\n","import {ITypedNode, TypedNode} from './TypedNode';\nimport {ITypedEdge, TypedEdge, TypedEdgeConfig} from \"./TypedEdge\";\nimport {BaseEdge, IBaseEdge} from \"../base/BaseEdge\";\nimport {BaseGraph} from '../base/BaseGraph';\nimport {GENERIC_TYPES} from \"../../config/run_config\";\nimport {BaseNode} from \"../base/BaseNode\";\nimport {\n\tDIR,\n\tExpansionInbounds,\n\tExpansionInput,\n\tExpansionConfig,\n\tExpansionResult,\n\tTypedGraphStats,\n\tTypedEdges,\n\tTypedNodes\n} from '../interfaces';\n\n\n/**\n * @description TypedGraph only takes TypedNodes & TypedEdges\n * @description coding standard: following Neo4j / Cypher standard,\n * node types should be in capital letters & edge types expressive\n * two-pieces separated by underscore (except 'GENERIC')\n * @todo enforce uppercase?\n * @description we could couple edge type & direction in order to\n * make the system more stringent, but this would result in a more\n * complex setup with the possibility of too many Errors thrown.\n * @solution for now, leave the type / direction combination to the\n * programmer & just assume internal consistency\n * @todo how to handle traversal when direction given goes against\n *       direction information in the edge object ?\n * @todo just don't specify direction in traversal / expand and only\n *       follow the direction specified in edge !?\n * @todo in the last case, how to handle undirected edges ?\n * @todo allow 'GENERIC' edge types ? => yes!\n */\nexport class TypedGraph extends BaseGraph {\n\tprotected _type: string;\n\n\t/**\n\t * We don't need an extra array of registered types, since an\n\t * acceptable recommendation graph will only contain a few single\n\t * up to a few dozen different types, which are quickly obtained\n\t * via Object.keys()\n\t */\n\tprotected _typedNodes: TypedNodes = new Map();\n\tprotected _typedEdges: TypedEdges = new Map();\n\n\n\tconstructor(public _label: string) {\n\t\tsuper(_label);\n\t\tthis._type = GENERIC_TYPES.Graph;\n\t\tthis._typedNodes.set(GENERIC_TYPES.Node, new Map());\n\t\tthis._typedEdges.set(GENERIC_TYPES.Edge, new Map());\n\t}\n\n\t/**\n\t * convenience methods\n\t */\n\tn(id: string) {\n\t\treturn this.getNodeById(id);\n\t}\n\n\tget type(): string {\n\t\treturn this._type;\n\t}\n\n\tnodeTypes(): string[] {\n\t\treturn Array.from(this._typedNodes.keys());\n\t}\n\n\tedgeTypes(): string[] {\n\t\treturn Array.from(this._typedEdges.keys());\n\t}\n\n\tnrTypedNodes(type: string): number | null {\n\t\ttype = type.toUpperCase();\n\t\treturn this._typedNodes.get(type) ? this._typedNodes.get(type).size : null;\n\t}\n\n\tnrTypedEdges(type: string): number | null {\n\t\ttype = type.toUpperCase();\n\t\treturn this._typedEdges.get(type) ? this._typedEdges.get(type).size : null;\n\t}\n\n\t/**\n\t * Neighbor nodes depending on type\n\t */\n\tins(node: ITypedNode, type: string): Set<ITypedNode> {\n\t\tconst targets = node.ins(type);\n\t\tif (targets) {\n\t\t\treturn new Set([...targets].map(uid => this.n(TypedNode.nIDFromUID(uid)) as TypedNode));\n\t\t}\n\t}\n\n\touts(node: ITypedNode, type: string): Set<ITypedNode> {\n\t\tconst targets = node.outs(type);\n\t\tif (targets) {\n\t\t}\n\t\treturn new Set([...targets].map(uid => this.n(TypedNode.nIDFromUID(uid)) as TypedNode));\n\t}\n\n\tunds(node: ITypedNode, type: string): Set<ITypedNode> {\n\t\tconst targets = node.unds(type);\n\t\tif (targets) {\n\t\t\treturn new Set([...targets].map(uid => this.n(TypedNode.nIDFromUID(uid)) as TypedNode));\n\t\t}\n\t}\n\n\n\t/**\n\t * @todo abomination...\n\t */\n\tstatic convertToExpansionResult(input: ExpansionInput): ExpansionResult {\n\t\tif (BaseNode.isTyped(input)) {\n\t\t\treturn {set: new Set([input]), freq: new Map<ITypedNode, number>()};\n\t\t} else if (input instanceof Set) {\n\t\t\treturn {set: input as Set<ITypedNode>, freq: new Map<ITypedNode, number>()};\n\t\t} else {\n\t\t\treturn input as ExpansionResult;\n\t\t}\n\t}\n\n\n\t/**\n\t * Neighbor nodes depending on type\n\t * @description takes either a single TypedNode or a Set of TypedNodes as input\n\t * @description we have to start with node objects, since dupe-checkable strings\n\t *              are only available once we deal with edge/neighborhood entries\n\t *              However, we then need to switch to an `intermediate representation`\n\t *              using those strings for dupe checking, and in the end map back to\n\t *              a node set...\n\t * @description In case of multiple input nodes, they could reference each other...\n\t *       -> Neo4j allows that, so we allow it as well (for now ;-))\n\t *\n\t * @todo decide if this difference in representation between node->neighbors &\n\t *       graph->nodeNeighbors is a problem or not (also performance-wise) !?\n\t * @todo decide if method call via [dir] is an abomination or not\n\t *       -> definitely screws up code assist / intellisense !\n\t *       -> (we all know it is...)\n\t *\n\t *\n\t *\n\t * @TODO draw a decision diagram...!\n\t * @TODO create a small, manageable test graph for expand(K)/periphery@K scenarios\n\t * \t\t\t -> and put those test cases into the SYNC suite\n\t */\n\texpand(input: ExpansionInput, dir: DIR, type: string): ExpansionResult {\n\t\t// const expansionInbounds : ExpansionInbounds = {};\n\n\t\tconst nodes: ExpansionResult = TypedGraph.convertToExpansionResult(input);\n\t\tconst resultSet = new Set<ITypedNode>();\n\t\tconst freqMap = new Map<ITypedNode, number>();\n\n\t\tfor (let node of nodes.set) {\n\t\t\tconst targets = node[dir](type);\n\t\t\tif (!targets) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (let target of targets) {\n\t\t\t\tlet nodeRef = this.n(TypedNode.nIDFromUID(target)) as TypedNode;\n\n\t\t\t\tif (!freqMap.has(nodeRef)) {\n\t\t\t\t\t// if we already have a frequency entry for this source node, we'll use it for initialization\n\t\t\t\t\t// since if #paths already led to this node, and we have a path from this node to the\n\t\t\t\t\t// target, then we got #paths to the target from whatever original source\n\t\t\t\t\tif (nodes.freq.get(node)) {\n\t\t\t\t\t\tfreqMap.set(nodeRef, nodes.freq.get(node));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfreqMap.set(nodeRef, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (resultSet.has(nodeRef)) {\n\t\t\t\t\tfreqMap.set(nodeRef, freqMap.get(nodeRef) + nodes.freq.get(node));\n\t\t\t\t}\n\t\t\t\tresultSet.add(nodeRef);\n\t\t\t}\n\t\t}\n\t\treturn {set: resultSet, freq: freqMap};\n\t}\n\n\n\t/**\n\t * expand over k steps\n\t *\n\t * @description like neo4j's `-[:REL*1..k]->`\n\t *              returning the node sets at distance <= `k`\n\t */\n\texpandK(input: ExpansionInput, dir: DIR, type: string, cfg: ExpansionConfig = {}): ExpansionResult {\n\t\tif (cfg.k < 0) {\n\t\t\tthrow new Error('cowardly refusing to expand a negative number of steps.');\n\t\t}\n\t\tlet k = cfg.k && cfg.k < this._nr_nodes ? cfg.k : this._nr_nodes - 1;\n\n\t\tlet nodes: ExpansionResult = TypedGraph.convertToExpansionResult(input);\n\t\tlet resultSet = new Set<ITypedNode>();\n\t\tconst freqMap = new Map<ITypedNode, number>();\n\n\t\twhile (k--) {\n\t\t\tnodes = this.expand(nodes, dir, type);\n\n\t\t\tfor (let nodeRef of nodes.set) {\n\t\t\t\tif (!freqMap.has(nodeRef)) {\n\t\t\t\t\tfreqMap.set(nodeRef, nodes.freq.get(nodeRef));\n\t\t\t\t}\n\t\t\t\tif (resultSet.has(nodeRef)) {\n\t\t\t\t\tfreqMap.set(nodeRef, freqMap.get(nodeRef) + nodes.freq.get(nodeRef));\n\n\t\t\t\t}\n\t\t\t\tresultSet.add(nodeRef);\n\t\t\t}\n\t\t}\n\t\treturn {set: resultSet, freq: freqMap};\n\t}\n\n\n\t/**\n\t * @description like neo4j's `-[:REL*k]->`\n\t *              only returning the node set at distance `k`\n\t */\n\tperipheryAtK(input: ExpansionInput, dir: DIR, type: string, cfg: ExpansionConfig = {}): ExpansionResult {\n\t\tif (cfg.k < 0) {\n\t\t\tthrow new Error('cowardly refusing to expand a negative number of steps.');\n\t\t}\n\t\tlet nodes: ExpansionResult = TypedGraph.convertToExpansionResult(input);\n\t\tlet k = cfg.k && cfg.k < this._nr_nodes ? cfg.k : this._nr_nodes - 1;\n\n\t\tfor ( let it = 0; it < k; it++ ) {\n\t\t\tnodes = this.expand(nodes, dir, type);\n\t\t}\n\t\treturn nodes;\n\t}\n\n\n\t/**\n\t * TYPED HISTOGRAMS\n\t */\n\tinHistT(nType: string, eType: string): Set<number>[] {\n\t\treturn this.degreeHistT(DIR.in, nType, eType);\n\t}\n\n\toutHistT(nType: string, eType: string): Set<number>[] {\n\t\treturn this.degreeHistT(DIR.out, nType, eType);\n\t}\n\n\tconnHistT(nType: string, eType: string): Set<number>[] {\n\t\treturn this.degreeHistT(DIR.und, nType, eType);\n\t}\n\n\tprivate degreeHistT(dir: string, nType: string, eType: string): Set<number>[] {\n\t\tlet result = [];\n\n\t\tfor (let [node_id, node] of this._typedNodes.get(nType)) {\n\t\t\tlet deg;\n\t\t\tswitch (dir) {\n\t\t\t\tcase DIR.in:\n\t\t\t\t\tdeg = node.ins(eType) ? node.ins(eType).size : 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase DIR.out:\n\t\t\t\t\tdeg = node.outs(eType) ? node.outs(eType).size : 0;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tdeg = node.unds(eType) ? node.unds(eType).size : 0;\n\t\t\t}\n\t\t\tif (!result[deg]) {\n\t\t\t\tresult[deg] = new Set([node]);\n\t\t\t} else {\n\t\t\t\tresult[deg].add(node);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\n\t/**\n\t * @todo difference to super ??\n\t * @param id\n\t * @param opts\n\t */\n\taddNodeByID(id: string, opts?: {}): ITypedNode {\n\t\tif (this.hasNodeID(id)) {\n\t\t\tthrow new Error(\"Won't add node with duplicate ID.\");\n\t\t}\n\t\tlet node = new TypedNode(id, opts);\n\t\treturn this.addNode(node) ? node : null;\n\t}\n\n\n\taddNode(node: ITypedNode): ITypedNode {\n\t\tif (!super.addNode(node)) {\n\t\t\treturn null;\n\t\t}\n\t\t// logger.log(JSON.stringify(node));\n\n\t\tconst\n\t\t\tid = node.getID(),\n\t\t\ttype = node.type ? node.type.toUpperCase() : null;\n\n\t\t/**\n\t\t *  Untyped nodes will be treated as `generic` type\n\t\t */\n\t\tif (!type) {\n\t\t\t// logger.log(`Received node type: ${type}`);\n\n\t\t\tthis._typedNodes.get(GENERIC_TYPES.Node).set(id, node);\n\t\t} else {\n\t\t\tif (!this._typedNodes.get(type)) {\n\t\t\t\tthis._typedNodes.set(type, new Map());\n\t\t\t}\n\t\t\tthis._typedNodes.get(type).set(id, node);\n\t\t}\n\t\treturn node;\n\t}\n\n\n\tgetNodeById(id: string): TypedNode {\n\t\treturn super.getNodeById(id) as TypedNode;\n\t}\n\n\n\tgetNodesT(type: string) {\n\t\treturn this._typedNodes.get(type.toUpperCase());\n\t}\n\n\n\tgetEdgesT(type: string) {\n\t\treturn this._typedEdges.get(type.toUpperCase());\n\t}\n\n\n\tdeleteNode(node: ITypedNode): void {\n\t\tconst id = node.getID(),\n\t\t\ttype = node.type ? node.type.toUpperCase() : GENERIC_TYPES.Node;\n\n\t\tif (!this._typedNodes.get(type)) {\n\t\t\tthrow Error('Node type does not exist on this TypedGraph.');\n\t\t}\n\t\tconst removeNode = this._typedNodes.get(type).get(id);\n\t\tif (!removeNode) {\n\t\t\tthrow Error('This particular node is nowhere to be found in its typed set.')\n\t\t}\n\t\tthis._typedNodes.get(type).delete(id);\n\t\tif (this.nrTypedNodes(type) === 0) {\n\t\t\tthis._typedNodes.delete(type);\n\t\t}\n\n\t\tsuper.deleteNode(node);\n\t}\n\n\n\taddEdgeByID(id: string, a: ITypedNode, b: ITypedNode, opts?: TypedEdgeConfig): ITypedEdge {\n\t\tlet edge = new TypedEdge(id, a, b, opts || {});\n\t\treturn this.addEdge(edge);\n\t}\n\n\n\taddEdge(edge: ITypedEdge | IBaseEdge): ITypedEdge {\n\t\tif (!super.addEdge(edge)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst id = edge.getID();\n\t\tlet type = GENERIC_TYPES.Edge;\n\t\tif (BaseEdge.isTyped(edge) && edge.type) {\n\t\t\ttype = edge.type.toUpperCase();\n\t\t}\n\n\t\t// logger.log('Got edge label: ' + edge.label);\n\t\t// logger.log('Got edge type: ' + type);\n\n\t\t/**\n\t\t *  Same procedure as every node...\n\t\t */\n\t\tif (id === type) {\n\t\t\tthis._typedEdges.get(GENERIC_TYPES.Edge).set(id, edge as ITypedEdge);\n\t\t} else {\n\t\t\tif (!this._typedEdges.get(type)) {\n\t\t\t\tthis._typedEdges.set(type, new Map());\n\t\t\t}\n\t\t\tthis._typedEdges.get(type).set(id, edge as ITypedEdge);\n\t\t}\n\t\treturn edge as ITypedEdge;\n\t}\n\n\n\tdeleteEdge(edge: ITypedEdge | IBaseEdge): void {\n\t\tconst id = edge.getID();\n\t\tlet type = GENERIC_TYPES.Edge;\n\t\tif (BaseEdge.isTyped(edge) && edge.type) {\n\t\t\ttype = edge.type.toUpperCase();\n\t\t}\n\t\tif (!this._typedEdges.get(type)) {\n\t\t\tthrow Error('Edge type does not exist on this TypedGraph.');\n\t\t}\n\t\tconst removeEdge = this._typedEdges.get(type).get(id);\n\t\tif (!removeEdge) {\n\t\t\tthrow Error('This particular edge is nowhere to be found in its typed set.')\n\t\t}\n\t\tthis._typedEdges.get(type).delete(id);\n\t\tif (this.nrTypedEdges(type) === 0) {\n\t\t\tthis._typedEdges.delete(type);\n\t\t}\n\t\tsuper.deleteEdge(edge);\n\t}\n\n\n\tgetStats(): TypedGraphStats {\n\t\tlet typed_nodes = {},\n\t\t\ttyped_edges = {};\n\t\tthis._typedNodes.forEach((k, v) => typed_nodes[v] = k.size);\n\t\tthis._typedEdges.forEach((k, v) => typed_edges[v] = k.size);\n\t\treturn {\n\t\t\t...super.getStats(),\n\t\t\t// node_types: this.nodeTypes(),\n\t\t\t// edge_types: this.edgeTypes(),\n\t\t\ttyped_nodes,\n\t\t\ttyped_edges\n\t\t};\n\t}\n\n}\n","import * as $N from '../core/base/BaseNode';\nimport * as $G from '../core/base/BaseGraph';\nimport * as $SU from '../utils/StructUtils'\n\nexport enum DegreeMode {\n  in,\n  out,\n  und,\n  dir,\n  all\n}\n\n/**\n * @todo per edge type ???\n */\nexport interface DegreeDistribution {\n\tin\t: Uint32Array;\n\tout\t: Uint32Array;\n\tdir\t: Uint32Array;\n\tund\t: Uint32Array;\n\tall\t: Uint32Array;\n}\n\n\nclass DegreeCentrality {\n\n  constructor(){}\n\n  getCentralityMap( graph: $G.IGraph, weighted?: boolean, conf?: DegreeMode):{[id:string]: number} {\n    weighted = ( weighted != null ) ? !!weighted : true;\n    conf = ( conf == null ) ? DegreeMode.all : conf;\n    \n    let ret:{[id:string]: number} = {}; //Will be a map of [nodeID] = centrality\n\n    switch(conf){ //Switch on the outside for faster loops\n      case DegreeMode.in:\n        for(let key in graph.getNodes()) {\n          let node = graph.getNodeById(key);\n          if(node!=null) {\n            if(!weighted) {\n              ret[key] = node.in_deg;\n            }\n            else {\n              ret[key] = ret[key]||0;\n              for(let k in node.inEdges()) {\n                ret[key] += node.inEdges()[k].getWeight();\n              }\n            }\n          }\n        }\n        break;\n\n      case DegreeMode.out:\n        for(let key in graph.getNodes()) {\n          let node = graph.getNodeById(key);\n          if(node!=null) {\n            if(!weighted) {\n              ret[key] = node.out_deg;\n            }\n            else {\n              ret[key] = ret[key]||0;\n              for(let k in node.outEdges()) {\n                ret[key] += node.outEdges()[k].getWeight();\n              }\n            }\n          }\n        }\n        break;\n\n      case DegreeMode.und:\n        for(let key in graph.getNodes()) {\n          let node = graph.getNodeById(key);\n          if(node!=null) {\n            if(!weighted) {\n              ret[key] = node.deg;\n            }\n            else {\n              ret[key] = ret[key]||0;\n              for(let k in node.undEdges()) {\n                ret[key] += node.undEdges()[k].getWeight();\n              }\n            }\n          }\n        }\n        break;\n\n      case DegreeMode.dir:\n        for(let key in graph.getNodes()) {\n          let node = graph.getNodeById(key);\n          if(node!=null) {\n            if(!weighted) {\n              ret[key] = node.in_deg + node.out_deg;\n            }\n            else {\n              ret[key] = ret[key]||0;\n              let comb = $SU.mergeObjects([node.inEdges(), node.outEdges()]);\n              for(let k in comb) {\n                ret[key] += comb[k].getWeight();\n              }\n            }\n          }\n        }\n        break;\n\n      case DegreeMode.all:\n        for(let key in graph.getNodes()) {\n          let node = graph.getNodeById(key);\n          if(node!=null) {\n            if(!weighted) {\n              ret[key] = node.deg + node.in_deg + node.out_deg;\n            }\n            else {\n              ret[key] = ret[key]||0;\n              let comb = $SU.mergeObjects([node.inEdges(), node.outEdges(), node.undEdges()]);\n              for(let k in comb) {\n                ret[key] += comb[k].getWeight();\n              }\n            }\n          }\n        }\n        break;\n    }\n    return ret;\n  }\n\n  \n\t/**\n\t * @TODO Weighted version !\n   * @TODO per edge type !\n\t */\n  degreeDistribution(graph: $G.IGraph) {\n\t\tlet max_deg : number = 0,\n        key\t\t\t: string,\n        nodes   : {[id: string] : $N.IBaseNode} = graph.getNodes(),\n\t\t\t\tnode \t\t: $N.IBaseNode,\n\t\t\t\tall_deg : number;\n\n\t\tfor ( key in nodes ) {\n\t\t\tnode = nodes[key];\n\t\t\tall_deg = node.in_deg + node.out_deg + node.deg + 1;\n\t\t\tmax_deg =  all_deg > max_deg ? all_deg : max_deg;\n\t\t}\n\n\t\tlet deg_dist : DegreeDistribution = {\n\t\t\tin: new Uint32Array(max_deg),\n\t\t\tout: new Uint32Array(max_deg),\n\t\t\tdir: new Uint32Array(max_deg),\n\t\t\tund: new Uint32Array(max_deg),\n\t\t\tall: new Uint32Array(max_deg)\n\t\t};\n\n\t\tfor ( key in nodes ) {\n\t\t\tnode = nodes[key];\n\t\t\tdeg_dist.in[node.in_deg]++;\n\t\t\tdeg_dist.out[node.out_deg]++;\n\t\t\tdeg_dist.dir[node.in_deg + node.out_deg]++;\n\t\t\tdeg_dist.und[node.deg]++;\n\t\t\tdeg_dist.all[node.in_deg + node.out_deg + node.deg]++;\n\t\t}\n\t\t// console.dir(deg_dist);\n\t\treturn deg_dist;\n\t}\n}\n\nexport {\n  DegreeCentrality\n};","import { IGraph, BaseGraph } from '../core/base/BaseGraph';\nimport { IBaseNode } from '../core/base/BaseNode';\nimport { IBaseEdge } from '../core/base/BaseEdge';\nimport { mergeObjects } from \"../utils/StructUtils\";\n\n// import { Logger } from \"../utils/Logger\";\n// const logger = new Logger();\n\n\nconst DEFAULT_WEIGHTED = false;\nconst DEFAULT_ALPHA = 0.15;\nconst DEFAULT_MAX_ITERATIONS = 1e3;\nconst DEFAULT_EPSILON = 1e-6;\nconst DEFAULT_NORMALIZE = false;\nconst defaultInit = (graph: IGraph) => 1 / graph.nrNodes();\n\n\nexport type InitMap = { [id: string]: number };\nexport type TeleSet = { [id: string]: number };\nexport type RankMap = { [id: string]: number };\n\n\n/**\n * Data structs we need for the array version of centralities\n * \n * @description we assume that nodes are always in the same order in the various arrays, \n *              with the exception of the pull sub-arrays, of course (which give the node index as values)\n *\n * @todo guarantee that the graph doesn't change during that mapping -> unmapping process \n *       already guaranteed by the single-threadedness of JS/Node, unless we build workers into it...\n */\nexport interface PRArrayDS {\n\tcurr: Array<number>;\n\told: Array<number>;\n\tout_deg: Array<number>;\n\tpull: Array<Array<number>>;\n\tpull_weight?: Array<Array<number>>;\n\tteleport?: Array<number>;\n\ttele_size?: number;\n}\n\n\n/**\n * Configuration object for PageRank class\n */\nexport interface PagerankRWConfig {\n\tweighted?: boolean;\n\talpha?: number;\n\tepsilon?: number;\n\tmaxIterations?: number;\n\tnormalize?: boolean;\n\tPRArrays?: PRArrayDS;\n\tpersonalized?: boolean;\n\ttele_set?: TeleSet;\n\tinit_map?: InitMap;\n}\n\n\n/**\n * Pagerank result type\n */\nexport interface PRResult {\n\tmap: RankMap;\n\tconfig: PagerankRWConfig;\n\titers: number;\n\tdelta: number;\n}\n\n\n/**\n * PageRank for all nodes of a given graph by performing Random Walks\n * Implemented to give the same results as the NetworkX implementation, just faster!\n * \n * @description We assume that all necessary properties of a node's feature vector\n *              has been incorporated into it's initial rank or the link structure\n *              of the graph. This means we carefully have to construct our graph\n *              before interpreting Pagerank as anything meaninful for a particular\n *              application.\n * \n * @todo find a paper / article detailing this implementation (it's the networkx numpy version...)\n * @todo compute a ground truth for our sample social networks (python!)\n * @todo compute a ground truth for our jobs / beer / northwind / meetup sample graphs (neo4j / networkx)\n */\nclass Pagerank {\n\tprivate readonly _weighted: boolean;\n\tprivate readonly _alpha: number;\n\tprivate readonly _epsilon: number;\n\tprivate readonly _maxIterations: number;\n\tprivate readonly _normalize: boolean;\n\tprivate readonly _personalized: boolean;\n\n  /**\n   * Holds all the data structures necessary to compute PR in LinAlg form\n   */\n\tprivate readonly _PRArrayDS: PRArrayDS;\n\n\tconstructor(private _graph: IGraph, config?: PagerankRWConfig) {\n\t\tconfig = config || {}; // just so we don't get `property of undefined` errors below\n\t\tthis._weighted = config.weighted || DEFAULT_WEIGHTED;\n\t\tthis._alpha = config.alpha || DEFAULT_ALPHA;\n\t\tthis._maxIterations = config.maxIterations || DEFAULT_MAX_ITERATIONS;\n\t\tthis._epsilon = config.epsilon || DEFAULT_EPSILON;\n\t\tthis._normalize = config.normalize || DEFAULT_NORMALIZE;\n\t\tthis._personalized = config.personalized ? config.personalized : false;\n\n\t\tif (this._personalized && !config.tele_set) {\n\t\t\tthrow Error(\"Personalized Pagerank requires tele_set as a config argument\");\n\t\t}\n\n\t\tif (config.init_map && Object.keys(config.init_map).length !== this._graph.nrNodes()) {\n\t\t\tthrow Error(\"init_map config parameter must be of size |nodes|\");\n\t\t}\n\n\t\tthis._PRArrayDS = config.PRArrays || {\n\t\t\tcurr: [],\n\t\t\told: [],\n\t\t\tout_deg: [],\n\t\t\tpull: [],\n\t\t\tpull_weight: this._weighted ? [] : null,\n\t\t\tteleport: config.tele_set ? [] : null,\n\t\t\ttele_size: config.tele_set ? 0 : null\n\t\t};\n\n\t\tconfig.PRArrays || this.constructPRArrayDataStructs(config);\n\t\t// logger.log(JSON.stringify(this._PRArrayDS));\n\t}\n\n\n\tgetConfig() : PagerankRWConfig {\n\t\treturn {\n\t\t\tweighted: this._weighted,\n\t\t\talpha: this._alpha,\n\t\t\tmaxIterations: this._maxIterations,\n\t\t\tepsilon: this._epsilon,\n\t\t\tnormalize: this._normalize\n\t\t}\n\t}\n\n\n\tgetDSs() {\n\t\treturn this._PRArrayDS;\n\t}\n\n\n\tconstructPRArrayDataStructs(config: PagerankRWConfig) {\n\t\tlet tic = +new Date;\n\n\t\tlet nodes = this._graph.getNodes();\n\t\tlet i = 0;\n\t\tlet teleport_prob_sum = 0;\n\t\tlet init_sum = 0;\n\n\t\tfor (let key in nodes) {\n\t\t\tlet node = this._graph.getNodeById(key);\n\n\t\t\t// set identifier to re-map later..\n\t\t\tnode.setFeature('PR_index', i);\n\n\t\t\tif (config.init_map) {\n\t\t\t\tif (config.init_map[key] == null) {\n\t\t\t\t\tthrow Error(\"initial value must be given for each node in the graph.\");\n\t\t\t\t}\n\t\t\t\tlet val = config.init_map[key];\n\t\t\t\tthis._PRArrayDS.curr[i] = val;\n\t\t\t\tthis._PRArrayDS.old[i] = val;\n\t\t\t\tinit_sum += val;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis._PRArrayDS.curr[i] = defaultInit(this._graph);\n\t\t\t\tthis._PRArrayDS.old[i] = defaultInit(this._graph);\n\t\t\t}\n\n\t\t\tthis._PRArrayDS.out_deg[i] = node.out_deg + node.deg;\n\n      /**\n       * @todo enhance this to actual weights!?\n       * @todo networkX requires a dict the size of the inputs, which is cumbersome for larger graphs\n       *       we want to do this smarter, but can we omit large parts of the (pseudo-)sparse matrix?\n       *       - where pseudo-sparse means containing only implicit values (jump chances)\n       */\n\t\t\tif (this._personalized) {\n\t\t\t\tlet tele_prob_node = config.tele_set[node.getID()] || 0;\n\t\t\t\tthis._PRArrayDS.teleport[i] = tele_prob_node;\n\t\t\t\tteleport_prob_sum += tele_prob_node;\n\t\t\t\ttele_prob_node && this._PRArrayDS.tele_size++;\n\t\t\t}\n\t\t\t++i;\n\t\t}\n\n\t\t// normalize init values\n\t\tif (config.init_map && init_sum !== 1) {\n\t\t\tthis._PRArrayDS.curr = this._PRArrayDS.curr.map(n => n /= init_sum);\n\t\t\tthis._PRArrayDS.old = this._PRArrayDS.old.map(n => n /= init_sum);\n\t\t}\n\n\t\t// normalize teleport probabilities\n\t\tif (this._personalized && teleport_prob_sum !== 1) {\n\t\t\tthis._PRArrayDS.teleport = this._PRArrayDS.teleport.map(n => n /= teleport_prob_sum);\n\t\t}\n\n\n    /**\n     * We can only do this once all the mappings [node_id => arr_idx] have been established!\n     */\n\t\tfor (let key in nodes) {\n\t\t\tlet node = this._graph.getNodeById(key);\n\t\t\tlet node_idx = node.getFeature('PR_index');\n\n\t\t\t// set nodes to pull from\n\t\t\tlet pull_i = [];\n\t\t\tlet pull_weight_i = [];\n\n\t\t\tlet incoming_edges = mergeObjects([node.inEdges(), node.undEdges()]);\n\t\t\tfor (let edge_key in incoming_edges) {\n\t\t\t\tlet edge: IBaseEdge = incoming_edges[edge_key];\n\t\t\t\tlet source: IBaseNode = edge.getNodes().a;\n\t\t\t\tif (edge.getNodes().a.getID() == node.getID()) {\n\t\t\t\t\tsource = edge.getNodes().b;\n\t\t\t\t}\n\t\t\t\tlet parent_idx = source.getFeature('PR_index');\n\t\t\t\tif (this._weighted) {\n\t\t\t\t\tpull_weight_i.push(edge.getWeight());\n\t\t\t\t}\n\t\t\t\tpull_i.push(parent_idx);\n\t\t\t}\n\t\t\tthis._PRArrayDS.pull[node_idx] = pull_i;\n\n      /**\n       * @todo test!\n       */\n\t\t\tif (this._weighted) {\n\t\t\t\tthis._PRArrayDS.pull_weight[node_idx] = pull_weight_i;\n\t\t\t}\n\t\t}\n\n\t\tlet toc = +new Date;\n\t\t// logger.log(`PR Array DS init took ${toc - tic} ms.`);\n\t}\n\n\n\tgetRankMapFromArray() : RankMap {\n\t\tlet result: RankMap = {};\n\t\tlet nodes = this._graph.getNodes();\n\t\tif (this._normalize) {\n\t\t\tthis.normalizePR();\n\t\t}\n\t\tfor (let key in nodes) {\n\t\t\tresult[key] = this._PRArrayDS.curr[nodes[key].getFeature('PR_index')];\n\t\t}\n\t\treturn result;\n\t}\n\n\n\tprivate normalizePR() {\n\t\tlet pr_sum = this._PRArrayDS.curr.reduce((i, j) => i + j, 0);\n\t\tif (pr_sum !== 1) {\n\t\t\tthis._PRArrayDS.curr = this._PRArrayDS.curr.map(n => n / pr_sum);\n\t\t}\n\t}\n\n\n\tpull2DTo1D(): Array<number> {\n\t\tlet p1d = [];\n\t\tlet p2d = this._PRArrayDS.pull;\n\n\t\tfor (let n in p2d) {\n\t\t\tfor (let i of p2d[n]) {\n\t\t\t\tp1d.push(i);\n\t\t\t}\n\t\t\t+n !== p2d.length - 1 && p1d.push(-1);\n\t\t}\n\t\treturn p1d;\n\t}\n\n\n\tcomputePR() : PRResult {\n\t\tconst ds = this._PRArrayDS;\n\t\tconst N = this._graph.nrNodes();\n\n\t\t// debug\n\t\tlet visits = 0;\n\t\tlet delta_iter: number;\n\n\t\tfor (let i = 0; i < this._maxIterations; ++i) {\n\t\t\tdelta_iter = 0.0;\n\n\t\t\t// node is number...\n\t\t\tfor (let node in ds.curr) {\n\n\t\t\t\tlet pull_rank = 0;\n\t\t\t\tvisits++;\n\n\t\t\t\tlet idx = 0;\n\t\t\t\tfor (let source of ds.pull[node]) {\n\t\t\t\t\tvisits++;\n          /**\n           * This should never happen....\n           * IF the data structure _PRArrayDS was properly constructed\n           * \n           * @todo properly test _PRArrayDS as well as this beauty\n           *       (using a contrived, wrongly constructed pull 2D array)\n           */\n\t\t\t\t\tif (ds.out_deg[source] === 0) {\n\t\t\t\t\t\tthrow ('Encountered zero divisor!');\n\t\t\t\t\t}\n\t\t\t\t\tlet weight = this._weighted ? ds.pull_weight[node][idx++] : 1.0;\n\t\t\t\t\tpull_rank += ds.old[source] * weight / ds.out_deg[source];\n\t\t\t\t}\n\n\t\t\t\tlet link_pr = (1 - this._alpha) * pull_rank;\n\n\t\t\t\tif (this._personalized) {\n\t\t\t\t\tlet jump_chance = ds.teleport[node] / ds.tele_size; // 0/x = 0\n\t\t\t\t\tds.curr[node] = link_pr + jump_chance;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// logger.log(`Pulling PR for node ${node}: ${link_pr  + this._alpha / N}`);\n\t\t\t\t\tds.curr[node] = link_pr + this._alpha / N;\n\t\t\t\t}\n\t\t\t\tdelta_iter += Math.abs(ds.curr[node] - ds.old[node]);\n\t\t\t}\n\n\t\t\tif (delta_iter <= this._epsilon) {\n\t\t\t\t// logger.log(`CONVERGED after ${i} iterations with ${visits} visits and a final delta of ${delta_iter}.`);\n\t\t\t\treturn {\n\t\t\t\t\tconfig: this.getConfig(),\n\t\t\t\t\tmap: this.getRankMapFromArray(),\n\t\t\t\t\titers: i,\n\t\t\t\t\tdelta: delta_iter\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tds.old = [...ds.curr];\n\t\t}\n\n\t\t// logger.log(`ABORTED after ${this._maxIterations} iterations with ${visits} visits.`);\n\t\treturn {\n\t\t\tconfig: this.getConfig(),\n\t\t\tmap: this.getRankMapFromArray(),\n\t\t\titers: this._maxIterations,\n\t\t\tdelta: delta_iter\n\t\t};\n\t}\n\n}\n\nexport { Pagerank }\n","import * as http from 'http';\nimport * as https from 'https';\n\nimport { Logger } from './Logger';\nconst logger = new Logger();\n\nconst SSL_PORT = '443';\n\nexport interface RequestConfig {\n\tremote_host: string,\n\tremote_path: string,\n\tfile_name: string\n}\n\n/**\n * @TODO: Test it !!!\n *\n * @param url\n * @param cb\n * @returns {ClientRequest}\n */\nexport function retrieveRemoteFile(config: RequestConfig, cb: Function) {\n  if ( typeof cb !== 'function' ) {\n    throw new Error('Provided callback is not a function.');\n  }\n\n  logger.log(`Requesting file via NodeJS request: ${config.remote_host}${config.remote_path}${config.file_name}`);\n\n  let options : https.RequestOptions = {\n    host: config.remote_host,\n    port: SSL_PORT,\n    path: config.remote_path + config.file_name,\n    method: 'GET'\n  };\n\n  let req = https.get(options, response => {\n\n    // Continuously update stream with data\n    var body = '';\n    response.setEncoding('utf8');\n    response.on('data', function(d) {\n      body += d;\n    });\n    response.on('end', function() {\n      // Received data in body...\n      cb(body);\n    });\n  });\n\n  req.on('error', e => {\n    logger.log(`Request error: ${e.message}`);\n  });\n  \n  return req;\n}\n\n\nexport function checkNodeEnvironment(): void {\n  if (typeof window !== 'undefined') {\n    throw new Error('When in Browser, do as the Browsers do! (use fetch and call readFromJSON() directly...) ')\n  }\n}\n","export interface Abbreviations {\n\tcoords\t\t\t\t: string;\n\tn_label\t\t\t\t: string;\n\tn_type\t\t\t\t: string;\n\tedges\t\t\t\t\t: string;\n\tn_features\t\t: string;\n\te_to\t\t\t\t\t: string;\n\te_dir\t\t\t\t\t: string;\n\te_weight\t\t\t: string;\n\te_label\t\t\t\t: string;\n\te_type\t\t\t\t: string;\n\te_features\t\t: string;\n}\n\n\nexport const labelKeys: Abbreviations = {\n\tcoords\t\t\t\t: 'c',\n\tn_label\t\t\t\t: 'l',\n\tn_type\t\t\t\t: 'x',\n\tn_features\t\t: 'f',\n\tedges\t\t\t\t\t: 'e',\n\te_to\t\t\t\t\t: 't', // a->b\n\te_dir\t\t\t\t\t: 'd',\n\te_weight\t\t\t: 'w',\n\te_label\t\t\t\t: 'l',\n\te_type\t\t\t\t: 'y',\n\te_features\t\t: 'f'\n};\n","import { BaseEdge, IBaseEdge } from '../../core/base/BaseEdge';\nimport { TypedEdge, ITypedEdge } from '../../core/typed/TypedEdge';\nimport { IBaseNode, NeighborEntry } from '../../core/base/BaseNode';\nimport { IGraph } from '../../core/base/BaseGraph';\nimport { TypedGraph } from '../../core/typed/TypedGraph';\n\n\nexport interface PotentialEdgeInfo {\n\ta\t\t\t\t\t\t\t: IBaseNode;\n\tb\t\t\t\t\t\t\t: IBaseNode;\n\tlabel?\t\t\t\t: string;\n\tdir\t\t\t\t\t\t: boolean;\n\tweighted\t\t\t: boolean;\n\tweight?\t\t\t\t: number;\n\ttyped\t\t\t\t\t: boolean;\n\ttype?\t\t\t\t\t: string;\n}\n\n\nclass EdgeDupeChecker {\n\n\tconstructor( private _graph: IGraph | TypedGraph ) {}\n\n\tisDupe(e: PotentialEdgeInfo): boolean {\n\t\tlet pds = this.potentialEndpoints(e);\n\t\tif ( !pds.size ) {\n\t\t\treturn false;\n\t\t}\n\t\t// logger.log(`Got ${pds.size} potential edge dupe`);\n\n\t\tfor ( let pd of pds.values() ) {\n\t\t\tif ( !EdgeDupeChecker.checkTypeWeightEquality(e, pd)\n\t\t\t\t|| !EdgeDupeChecker.typeWeightDupe(e, pd) ) {\n\t\t\t\tpds.delete(pd);\n\t\t\t}\n\t\t}\n\t\treturn !!pds.size;\n\t}\n\n\n\tpotentialEndpoints(e: PotentialEdgeInfo): Set<IBaseEdge | ITypedEdge> {\n\t\tconst result = new Set<IBaseEdge | ITypedEdge>();\n\n\t\tif ( e.dir ) {\n\t\t\te.a.nextNodes().forEach(ne => {\n\t\t\t\t(ne.node === e.b) && result.add(ne.edge);\n\t\t\t});\n\t\t}\n\t\telse {\n\t\t\te.a.connNodes().forEach(ne => {\n\t\t\t\t(ne.node === e.b) && result.add(ne.edge);\n\t\t\t});\n\t\t}\n\t\treturn result;\n\t}\n\n\n\t/**\n\t * @todo has no effect on test cases - either\n\t * \t\t\t -) test cases are not granular enough\n\t * \t\t\t -) typed-weighted-equality is irrelevant\n\t * @param e struct with potential edge info\n\t * @param oe other edge: IBaseEdge\n\t */\n\tstatic checkTypeWeightEquality(e: PotentialEdgeInfo, oe: IBaseEdge): boolean {\n\t\treturn BaseEdge.isTyped(oe) === e.typed && e.weighted === oe.isWeighted();\n\t}\n\n\n\tstatic typeWeightDupe(e: PotentialEdgeInfo, oe: IBaseEdge) : boolean {\n\t\tconst neitherTypedNorWeighted = !e.typed && !e.weighted;\n\t\tconst notTypedButWeighted = !e.typed && e.weighted;\n\t\tconst weightEqual = e.weight === oe.getWeight();\n\t\tconst typeEqual = e.typed && BaseEdge.isTyped(oe) && e.type === oe.type;\n\n\t\treturn ( neitherTypedNorWeighted || notTypedButWeighted && weightEqual || typeEqual );\n\t}\n}\n\n\nexport {\n\tEdgeDupeChecker\n}\n","// Unique ID creation requires a high quality random # generator.  In the\n// browser this is a little complicated due to unknown quality of Math.random()\n// and inconsistent support for the `crypto` API.  We do the best we can via\n// feature-detection\n\n// getRandomValues needs to be invoked in a context where \"this\" is a Crypto\n// implementation. Also, find the complete implementation of crypto on IE11.\nvar getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||\n                      (typeof(msCrypto) != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto));\n\nif (getRandomValues) {\n  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto\n  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef\n\n  module.exports = function whatwgRNG() {\n    getRandomValues(rnds8);\n    return rnds8;\n  };\n} else {\n  // Math.random()-based (RNG)\n  //\n  // If all else fails, use Math.random().  It's fast, but is of unspecified\n  // quality.\n  var rnds = new Array(16);\n\n  module.exports = function mathRNG() {\n    for (var i = 0, r; i < 16; i++) {\n      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return rnds;\n  };\n}\n","/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\nfor (var i = 0; i < 256; ++i) {\n  byteToHex[i] = (i + 0x100).toString(16).substr(1);\n}\n\nfunction bytesToUuid(buf, offset) {\n  var i = offset || 0;\n  var bth = byteToHex;\n  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4\n  return ([\n    bth[buf[i++]], bth[buf[i++]],\n    bth[buf[i++]], bth[buf[i++]], '-',\n    bth[buf[i++]], bth[buf[i++]], '-',\n    bth[buf[i++]], bth[buf[i++]], '-',\n    bth[buf[i++]], bth[buf[i++]], '-',\n    bth[buf[i++]], bth[buf[i++]],\n    bth[buf[i++]], bth[buf[i++]],\n    bth[buf[i++]], bth[buf[i++]]\n  ]).join('');\n}\n\nmodule.exports = bytesToUuid;\n","var rng = require('./lib/rng');\nvar bytesToUuid = require('./lib/bytesToUuid');\n\n// **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\nvar _nodeId;\nvar _clockseq;\n\n// Previous uuid creation time\nvar _lastMSecs = 0;\nvar _lastNSecs = 0;\n\n// See https://github.com/uuidjs/uuid for API details\nfunction v1(options, buf, offset) {\n  var i = buf && offset || 0;\n  var b = buf || [];\n\n  options = options || {};\n  var node = options.node || _nodeId;\n  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;\n\n  // node and clockseq need to be initialized to random values if they're not\n  // specified.  We do this lazily to minimize issues related to insufficient\n  // system entropy.  See #189\n  if (node == null || clockseq == null) {\n    var seedBytes = rng();\n    if (node == null) {\n      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n      node = _nodeId = [\n        seedBytes[0] | 0x01,\n        seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]\n      ];\n    }\n    if (clockseq == null) {\n      // Per 4.2.2, randomize (14 bit) clockseq\n      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;\n    }\n  }\n\n  // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();\n\n  // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;\n\n  // Time since last uuid creation (in msecs)\n  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;\n\n  // Per 4.2.1.2, Bump clockseq on clock regression\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  }\n\n  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  }\n\n  // Per 4.2.1.2 Throw error if too many uuids are requested\n  if (nsecs >= 10000) {\n    throw new Error('uuid.v1(): Can\\'t create more than 10M uuids/sec');\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq;\n\n  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n  msecs += 12219292800000;\n\n  // `time_low`\n  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff;\n\n  // `time_mid`\n  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff;\n\n  // `time_high_and_version`\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n  b[i++] = tmh >>> 16 & 0xff;\n\n  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n  b[i++] = clockseq >>> 8 | 0x80;\n\n  // `clock_seq_low`\n  b[i++] = clockseq & 0xff;\n\n  // `node`\n  for (var n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n\n  return buf ? buf : bytesToUuid(b);\n}\n\nmodule.exports = v1;\n","var rng = require('./lib/rng');\nvar bytesToUuid = require('./lib/bytesToUuid');\n\nfunction v4(options, buf, offset) {\n  var i = buf && offset || 0;\n\n  if (typeof(options) == 'string') {\n    buf = options === 'binary' ? new Array(16) : null;\n    options = null;\n  }\n  options = options || {};\n\n  var rnds = options.random || (options.rng || rng)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = (rnds[6] & 0x0f) | 0x40;\n  rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    for (var ii = 0; ii < 16; ++ii) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || bytesToUuid(rnds);\n}\n\nmodule.exports = v4;\n","var v1 = require('./v1');\nvar v4 = require('./v4');\n\nvar uuid = v4;\nuuid.v1 = v1;\nuuid.v4 = v4;\n\nmodule.exports = uuid;\n","import * as fs from 'fs';\nimport {IBaseEdge} from '../../core/base/BaseEdge';\nimport {IBaseNode} from \"../../core/base/BaseNode\";\nimport {ITypedNode} from \"../../core/typed/TypedNode\";\nimport {TypedGraph} from \"../../core/typed/TypedGraph\";\nimport {IGraph, BaseGraph} from '../../core/base/BaseGraph';\nimport * as $R from '../../utils/RemoteUtils';\nimport {labelKeys} from '../interfaces';\nimport {EdgeDupeChecker, PotentialEdgeInfo} from '../common/Dupes';\n\nimport * as uuid from 'uuid'\n\nconst v4 = uuid.v4;\n\nimport {Logger} from '../../utils/Logger';\nconst logger = new Logger();\n\n\nconst DEFAULT_WEIGHT: number = 1;\n\n\nexport interface JSONEdge {\n\tto: string;\n\tdirected?: string;\n\tweight?: string;\n\ttype?: string;\n}\n\n\nexport interface JSONNode {\n\tedges: Array<JSONEdge>;\n\tcoords?: { [key: string]: Number };\n\tfeatures?: { [key: string]: any };\n}\n\n\nexport interface JSONGraph {\n\ttypeRLT: {nodes: {}, edges: {}};\n\tname: string;\n\tnodes: number;\n\tedges: number;\n\tdata: { [key: string]: JSONNode };\n}\n\n\nexport interface IJSONInConfig {\n\texplicit_direction?\t\t: boolean;\n\tdirected?\t\t\t\t\t\t\t: boolean;\n\tweighted?\t\t\t\t\t\t\t: boolean;\n\ttyped?\t\t\t\t\t\t\t\t: boolean;\n\tdupeCheck? \t\t\t\t\t\t: boolean;\n}\n\n\nexport interface IJSONInput {\n\t_config: IJSONInConfig;\n\n\treadFromJSONFile(file: string, graph?: IGraph): IGraph;\n\n\treadFromJSON(json: {}, graph?: IGraph): IGraph;\n\n\treadFromJSONURL(config: $R.RequestConfig, cb: Function, graph?: IGraph): void;\n}\n\n\nclass JSONInput implements IJSONInput {\n\t_config: IJSONInConfig;\n\n\tconstructor(config: IJSONInConfig = {}) {\n\t\tthis._config = {\n\t\t\texplicit_direction: config.explicit_direction != null ? config.explicit_direction : true,\n\t\t\tdirected: config.directed != null ? config.directed : false,\n\t\t\tweighted: config.weighted != null ? config.weighted : false,\n\t\t\tdupeCheck: config.dupeCheck != null ? config.dupeCheck : true\n\t\t};\n\t}\n\n\n\treadFromJSONFile(filepath: string, graph?: IGraph): IGraph {\n\t\t$R.checkNodeEnvironment();\n\n\t\t// TODO test for existing file...\n\t\tlet json = JSON.parse(fs.readFileSync(filepath).toString());\n\t\treturn this.readFromJSON(json, graph);\n\t}\n\n\n\treadFromJSONURL(config: $R.RequestConfig, cb: Function, graph?: IGraph): void {\n\t\tconst self = this;\n\n\t\t// Assert we are in Node.js environment\n\t\t$R.checkNodeEnvironment();\n\n\t\t// Node.js\n\t\t$R.retrieveRemoteFile(config, function (raw_graph) {\n\t\t\tgraph = self.readFromJSON(JSON.parse(raw_graph), graph);\n\t\t\tcb(graph, undefined);\n\t\t});\n\t}\n\n\n\treadFromJSON(json: JSONGraph, graph?: IGraph | TypedGraph): IGraph | TypedGraph {\n\t\tgraph = graph || new BaseGraph(json.name);\n\t\tconst edc = new EdgeDupeChecker(graph);\n\t\tconst rlt = json.typeRLT;\n\t\t// logger.log(rlt);\n\n\t\tthis.addNodesToGraph(json, graph);\n\n\t\tfor (let node_id in json.data) {\n\t\t\tlet node = graph.getNodeById(node_id);\n\n\t\t\t// Reading and instantiating edges\n\t\t\tlet edges = json.data[node_id][labelKeys.edges];\n\t\t\tfor (let e in edges) {\n\t\t\t\tconst edge_input = edges[e];\n\t\t\t\t// BASE INFO\n\t\t\t\tconst target_node = this.getTargetNode(graph, edge_input);\n\t\t\t\tconst edge_label = edge_input[labelKeys.e_label];\n\t\t\t\tconst edge_type = rlt && rlt.edges[edge_input[labelKeys.e_type]] || null;\n\n\t\t\t\t// DIRECTION\n\t\t\t\tconst directed = this._config.explicit_direction ? !!edge_input[labelKeys.e_dir] : this._config.directed;\n\n\t\t\t\t// WEIGHTS\n\t\t\t\tconst weight_float = JSONInput.handleEdgeWeights(edge_input);\n\t\t\t\tconst weight_info = weight_float === weight_float ? weight_float : DEFAULT_WEIGHT;\n\t\t\t\tconst edge_weight = this._config.weighted ? weight_info : undefined;\n\n\t\t\t\t// EDGE_ID creation\n\t\t\t\t/**\n\t\t\t\t * @todo replace with uuid v4() -> then clean up the mess... ;-)\n\t\t\t\t */\n\t\t\t\tconst target_node_id = edge_input[labelKeys.e_to];\n\t\t\t\tconst dir_char = directed ? 'd' : 'u';\n\t\t\t\tconst edge_id = node_id + \"_\" + target_node_id + \"_\" + dir_char;\n\n\t\t\t\t// DUPLICATE or CREATE ??\n\t\t\t\tconst newEdge: PotentialEdgeInfo = {\n\t\t\t\t\ta: node,\n\t\t\t\t\tb: target_node,\n\t\t\t\t\tlabel: edge_label,\n\t\t\t\t\tdir: directed,\n\t\t\t\t\tweighted: this._config.weighted,\n\t\t\t\t\tweight: edge_weight,\n\t\t\t\t\ttyped: !!edge_type,\n\t\t\t\t\ttype: edge_type\n\t\t\t\t};\n\t\t\t\tif ( this._config.dupeCheck && edc.isDupe(newEdge) ) {\n\t\t\t\t\t// Don't throw, just log\n\t\t\t\t\t// logger.log(`Edge ${edge_id} is a duplicate according to assumptions... omitting.`);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tgraph.addEdgeByID(edge_id, node, target_node, {\n\t\t\t\t\tlabel: edge_label,\n\t\t\t\t\tdirected: directed,\n\t\t\t\t\tweighted: this._config.weighted,\n\t\t\t\t\tweight: edge_weight,\n\t\t\t\t\ttyped: !!edge_type,\n\t\t\t\t\ttype: edge_type\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\treturn graph;\n\t}\n\n\n\taddNodesToGraph(json: JSONGraph, graph: IGraph) {\n\t\tconst rlt = json.typeRLT;\n\n\t\tlet\n\t\t\tcoords_json: { [key: string]: any },\n\t\t\tcoords: { [key: string]: Number },\n\t\t\tcoord_idx: string,\n\t\t\tfeatures: { [key: string]: any };\n\n\t\tfor (let node_id in json.data) {\n\t\t\tconst type = BaseGraph.isTyped(graph) ? rlt && rlt.nodes[json.data[node_id][labelKeys.n_type]] : null;\n\t\t\tconst label = json.data[node_id][labelKeys.n_label];\n\t\t\tconst node = graph.addNodeByID(node_id, {label, type});\n\t\t\t// Here we set the reference...?\n\t\t\tfeatures = json.data[node_id][labelKeys.n_features];\n\t\t\tif (features) {\n\t\t\t\tnode.setFeatures(features);\n\t\t\t}\n\t\t\t// Here we copy...?\n\t\t\tcoords_json = json.data[node_id][labelKeys.coords];\n\t\t\tif (coords_json) {\n\t\t\t\tcoords = {};\n\t\t\t\tfor (coord_idx in coords_json) {\n\t\t\t\t\tcoords[coord_idx] = +coords_json[coord_idx];\n\t\t\t\t}\n\t\t\t\tnode.setFeature(labelKeys.coords, coords);\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/**\n\t * @todo implicitly add nodes referenced by edge\n\t *       but not present in graph input JSON ?\n\t */\n\tgetTargetNode(graph, edge_input): IBaseNode | ITypedNode {\n\t\tconst target_node_id = edge_input[labelKeys.e_to];\n\t\tconst target_node = graph.getNodeById(target_node_id);\n\t\tif (!target_node) {\n\t\t\tthrow new Error('Node referenced by edge does not exist');\n\t\t}\n\t\treturn target_node;\n\t}\n\n\n\t/**\n\t * Infinity & -Infinity cases are redundant, as JavaScript\n\t * handles them correctly anyways (for now)\n\t * @param edge_input\n\t */\n\tstatic handleEdgeWeights(edge_input): number {\n\t\tswitch (edge_input[labelKeys.e_weight]) {\n\t\t\tcase \"undefined\":\n\t\t\t\treturn DEFAULT_WEIGHT;\n\t\t\tcase \"Infinity\":\n\t\t\t\treturn Number.POSITIVE_INFINITY;\n\t\t\tcase \"-Infinity\":\n\t\t\t\treturn Number.NEGATIVE_INFINITY;\n\t\t\tcase \"MAX\":\n\t\t\t\treturn Number.MAX_VALUE;\n\t\t\tcase \"MIN\":\n\t\t\t\treturn Number.MIN_VALUE;\n\t\t\tdefault:\n\t\t\t\treturn parseFloat(edge_input[labelKeys.e_weight])\n\t\t}\n\t}\n}\n\nexport {JSONInput}\n","import * as fs from 'fs';\n\nimport * as $N from '../../core/base/BaseNode';\nimport * as $E from '../../core/base/BaseEdge';\nimport * as $G from '../../core/base/BaseGraph';\n\nimport {labelKeys} from '../interfaces';\nimport {BaseEdge} from \"../../core/base/BaseEdge\";\nimport {BaseNode} from \"../../core/base/BaseNode\";\nimport {TypedGraph} from \"../../core/typed/TypedGraph\";\nimport {BaseGraph} from \"../../core/base/BaseGraph\";\n\n\nexport interface IJSONOutput {\n\twriteToJSONFile(filepath: string, graph: $G.IGraph): void;\n\n\twriteToJSONString(graph: $G.IGraph): string;\n}\n\n\nexport interface TypeLUT {\n\tnodes: { [key: string]: string };\n\tedges: { [key: string]: string };\n}\n\nconst startChar: number = 64;\n\n\nclass JSONOutput implements IJSONOutput {\n\n\t// constructor() {}\n\n\tconstructTypeRLUT(g: TypedGraph): [TypeLUT, TypeLUT] {\n\t\tlet nchar = startChar;\n\t\tlet echar = startChar;\n\t\tconst lut: TypeLUT = {\n\t\t\tnodes: {},\n\t\t\tedges: {}\n\t\t};\n\t\tconst rlut: TypeLUT = {\n\t\t\tnodes: {},\n\t\t\tedges: {}\n\t\t};\n\n\t\tconst ntypes = g.nodeTypes();\n\t\tfor (let t of ntypes) {\n\t\t\tlut.nodes[t] = String.fromCharCode(nchar);\n\t\t\trlut.nodes[String.fromCharCode(nchar++)] = t;\n\t\t}\n\t\tconst etypes = g.edgeTypes();\n\t\tfor ( let t of etypes ) {\n\t\t\tlut.edges[t] = String.fromCharCode(echar);\n\t\t\trlut.edges[String.fromCharCode(echar++)] = t;\n\t\t}\n\t\treturn [lut, rlut];\n\t}\n\n\n\twriteToJSONFile(filepath: string, graph: $G.IGraph): void {\n\t\tif (typeof window !== 'undefined' && window !== null) {\n\t\t\tthrow new Error('cannot write to File inside of Browser');\n\t\t}\n\t\tfs.writeFileSync(filepath, this.writeToJSONString(graph));\n\t}\n\n\n\twriteToJSONString(graph: $G.IGraph): string {\n\t\tlet lut: TypeLUT = null;\n\t\tlet rlt: TypeLUT = null;\n\n\t\tlet nodes: { [key: string]: $N.IBaseNode },\n\t\t\tnode: $N.IBaseNode,\n\t\t\tnode_struct,\n\t\t\tund_edges: { [key: string]: $E.IBaseEdge } | {},\n\t\t\tdir_edges: { [key: string]: $E.IBaseEdge } | {},\n\t\t\tedge: $E.IBaseEdge,\n\t\t\tcoords;\n\n\t\tlet result = {\n\t\t\tname: graph.label,\n\t\t\tnodes: graph.nrNodes(),\n\t\t\tdir_e: graph.nrDirEdges(),\n\t\t\tund_e: graph.nrUndEdges(),\n\t\t\tdata: {}\n\t\t};\n\n\t\tif ( BaseGraph.isTyped(graph) ) {\n\t\t\t[lut, rlt] = this.constructTypeRLUT(graph);\n\t\t}\n\t\tif ( rlt ) {\n\t\t\tresult['typeRLT'] = rlt;\n\t\t}\n\n\t\t// Go through all nodes \n\t\tnodes = graph.getNodes();\n\t\tfor (let node_key in nodes) {\n\t\t\tnode = nodes[node_key];\n\t\t\tnode_struct = result.data[node.getID()] = {\n\t\t\t\t[labelKeys.edges]: []\n\t\t\t};\n\t\t\tif (node.getID() !== node.getLabel()) {\n\t\t\t\tnode_struct[labelKeys.n_label] = node.label;\n\t\t\t}\n\t\t\tif (BaseNode.isTyped(node)) {\n\t\t\t\tnode_struct[labelKeys.n_type] = lut && lut.nodes[node.type];\n\t\t\t}\n\n\n\t\t\t/* -------------------------------------- */\n\t\t\t/*\t\t\t\t\t UNDIRECTED edges\t\t\t\t\t\t\t*/\n\t\t\t/* -------------------------------------- */\n\t\t\tund_edges = node.undEdges();\n\t\t\tfor (let edge_key in und_edges) {\n\t\t\t\tedge = und_edges[edge_key];\n\t\t\t\tlet endPoints = edge.getNodes();\n\n\t\t\t\tlet edgeStruct = {\n\t\t\t\t\t[labelKeys.e_to]: endPoints.a.getID() === node.getID() ? endPoints.b.getID() : endPoints.a.getID(),\n\t\t\t\t\t[labelKeys.e_dir]: edge.isDirected() ? 1 : 0,\n\t\t\t\t\t[labelKeys.e_weight]: JSONOutput.handleEdgeWeight(edge)\n\t\t\t\t};\n\t\t\t\tif ( Object.keys(edge.getFeatures()).length ) {\n\t\t\t\t\tedgeStruct[labelKeys.e_features] = JSON.stringify(edge.getFeatures())\n\t\t\t\t}\n\t\t\t\tif (edge.getID() !== edge.getLabel()) {\n\t\t\t\t\tedgeStruct[labelKeys.e_label] = edge.getLabel();\n\t\t\t\t}\n\t\t\t\tif (BaseEdge.isTyped(edge)) {\n\t\t\t\t\tedgeStruct[labelKeys.e_type] = lut && lut.edges[edge.type];\n\t\t\t\t}\n\t\t\t\tnode_struct[labelKeys.edges].push(edgeStruct);\n\t\t\t}\n\n\n\t\t\t/* -------------------------------------- */\n\t\t\t/*\t\t\t\t\t\tDIRECTED edges\t\t\t\t\t\t\t*/\n\t\t\t/* -------------------------------------- */\n\t\t\tdir_edges = node.outEdges();\n\t\t\tfor (let edge_key in dir_edges) {\n\t\t\t\tedge = dir_edges[edge_key];\n\t\t\t\tlet endPoints = edge.getNodes();\n\n\t\t\t\tlet edgeStruct = {\n\t\t\t\t\t[labelKeys.e_to]: endPoints.b.getID(),\n\t\t\t\t\t[labelKeys.e_dir]: edge.isDirected() ? 1 : 0,\n\t\t\t\t\t[labelKeys.e_weight]: JSONOutput.handleEdgeWeight(edge)\n\t\t\t\t};\n\t\t\t\tif ( Object.keys(edge.getFeatures()).length ) {\n\t\t\t\t\tedgeStruct[labelKeys.e_features] = JSON.stringify(edge.getFeatures())\n\t\t\t\t}\n\t\t\t\tif (edge.getID() !== edge.getLabel()) {\n\t\t\t\t\tedgeStruct[labelKeys.e_label] = edge.getLabel();\n\t\t\t\t}\n\t\t\t\tif (BaseEdge.isTyped(edge)) {\n\t\t\t\t\tedgeStruct[labelKeys.e_type] = lut && lut.edges[edge.type];\n\t\t\t\t}\n\t\t\t\tnode_struct[labelKeys.edges].push(edgeStruct);\n\t\t\t}\n\n\t\t\t// Features\n\t\t\tnode_struct[labelKeys.n_features] = node.getFeatures();\n\n\t\t\t// Coords (shall we really?)\n\t\t\tif ((coords = node.getFeature(labelKeys.coords)) != null) {\n\t\t\t\tnode_struct[labelKeys.coords] = coords;\n\t\t\t}\n\t\t}\n\n\t\treturn JSON.stringify(result);\n\t}\n\n\n\tstatic handleEdgeWeight(edge: $E.IBaseEdge): string | number {\n\t\tif (!edge.isWeighted()) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tswitch (edge.getWeight()) {\n\t\t\tcase Number.POSITIVE_INFINITY:\n\t\t\t\treturn 'Infinity';\n\t\t\tcase Number.NEGATIVE_INFINITY:\n\t\t\t\treturn '-Infinity';\n\t\t\tcase Number.MAX_VALUE:\n\t\t\t\treturn 'MAX';\n\t\t\tcase Number.MIN_VALUE:\n\t\t\t\treturn 'MIN';\n\t\t\tdefault:\n\t\t\t\treturn edge.getWeight();\n\t\t}\n\t}\n}\n\nexport {JSONOutput}","import * as $I from './interfaces';\n\n/*----------------------------------*/\n/*\t\t\t\t\t\t\tCONSTS\t\t\t\t\t\t\t*/\n/*----------------------------------*/\n\nexport const setSimFuncs = {\n\tjaccard,\n\toverlap\n};\n\nconst PRECISION = 5;\n\n\n/*----------------------------------*/\n/*\t\t\tSET SIMILARITY MEASURES\t\t\t*/\n/*----------------------------------*/\n\n\n/**\n * @param a set A\n * @param b set B\n */\nfunction jaccard(a: Set<any>, b: Set<any>) : $I.Similarity {\n\tconst ui = unionIntersect(a, b);\n\treturn {\n\t\tisect: ui.isectSize,\n\t\tsim: +(ui.isectSize / ui.unionSize).toPrecision(PRECISION)\n\t}\n}\n\n\n/**\n * @description commonly used to detect sub/super relationships\n * @param a \n * @param b \n */\nfunction overlap(a: Set<any>, b: Set<any>) : $I.Similarity {\n\tconst ui = unionIntersect(a, b);\n\treturn {\n\t\tisect: ui.isectSize,\n\t\tsim: +(ui.isectSize / Math.min(a.size, b.size)).toPrecision(PRECISION)\n\t}\n}\n\n\nfunction unionIntersect(a: Set<any>, b: Set<any>) {\n\tconst unionSize = new Set([...Array.from(a), ...Array.from(b)]).size;\n\tconst isectSize = a.size + b.size - unionSize;\n\treturn {unionSize, isectSize};\n}\n\n","import * as $I from './interfaces';\nimport {IBaseNode} from '../core/base/BaseNode';\n\nconst PRECISION = 5;\n\nexport const scoreSimFuncs = {\n\tcosine,\n\tcosineSets,\n\teuclidean,\n\teuclideanSets,\n\tpearson,\n\tpearsonSets\n};\n\n\n/*----------------------------------*/\n/*\t\t\tSET SIMILARITY MEASURES\t\t\t*/\n\n/*----------------------------------*/\n\n\nfunction euclidean(a: number[], b: number[]) {\n\tif (a.length !== b.length) {\n\t\tthrow new Error('Vectors must be of same size');\n\t}\n\tconst at = a.length < 1e4 ? a : new Float32Array(a);\n\tconst bt = b.length < 1e4 ? b : new Float32Array(b);\n\n\tlet sum = 0, diff = 0;\n\tfor (let i = 0; i < at.length; i++) {\n\t\tdiff = at[i] - bt[i];\n\t\tsum += diff * diff;\n\t}\n\tlet sim = +Math.sqrt(sum).toPrecision(PRECISION);\n\t// console.log(sim);\n\treturn {sim};\n}\n\n\n/**\n *\n * @param a\n * @param b\n */\nfunction cosine(a: number[], b: number[]) {\n\tif (a.length !== b.length) {\n\t\tthrow new Error('Vectors must be of same size');\n\t}\n\tconst fa1 = new Float32Array(a);\n\tconst fa2 = new Float32Array(b);\n\tlet numerator = 0;\n\tfor (let i = 0; i < fa1.length; i++) {\n\t\tnumerator += fa1[i] * fa2[i];\n\t}\n\tlet dena = 0, denb = 0;\n\tfor (let i = 0; i < fa1.length; i++) {\n\t\tdena += fa1[i] * fa1[i];\n\t\tdenb += fa2[i] * fa2[i];\n\t}\n\tdena = Math.sqrt(dena);\n\tdenb = Math.sqrt(denb);\n\treturn {sim: +(numerator / (dena * denb)).toPrecision(PRECISION)};\n}\n\n\n/**\n *\n * @param a scores of user A for common targets\n * @param b scores of user B for common targets\n * @param a_mean avg rating for user a across ALL their ratings\n * @param b_mean avg rating for user b across ALL their ratings\n */\nfunction pearson(a: number[], b: number[], a_mean?: number, b_mean?: number) {\n\tif (a.length !== b.length) {\n\t\tthrow new Error('Vectors must be of same size');\n\t}\n\tlet sum_a = 0,\n\t\tsum_b = 0,\n\t\tmean_a = a_mean || 0,\n\t\tmean_b = b_mean || 0,\n\t\tnumerator = 0,\n\t\tdiff_a_sq = 0,\n\t\tdiff_b_sq = 0,\n\t\tdenominator,\n\t\ta_diff,\n\t\tb_diff,\n\t\tsim;\n\n\tif (!a_mean || !b_mean) {\n\t\tfor (let i = 0; i < a.length; i++) {\n\t\t\tsum_a += a[i];\n\t\t\tsum_b += b[i];\n\t\t}\n\t\tmean_a = sum_a / a.length;\n\t\tmean_b = sum_b / b.length;\n\t}\n\n\tfor (let i = 0; i < a.length; i++) {\n\t\ta_diff = a[i] - mean_a;\n\t\tb_diff = b[i] - mean_b;\n\t\tnumerator += a_diff * b_diff;\n\t\tdiff_a_sq += a_diff * a_diff;\n\t\tdiff_b_sq += b_diff * b_diff;\n\t}\n\tdenominator = Math.sqrt(diff_a_sq) * Math.sqrt(diff_b_sq);\n\tsim = +(numerator / denominator).toPrecision(PRECISION);\n\treturn {sim};\n}\n\n\n/**\n * @description first extract\n * @param a\n * @param b\n */\nfunction cosineSets(a: Set<string>, b: Set<string>) {\n\tconst [aa, ba] = extractCommonTargetScores(a, b);\n\tif (!aa.length || !ba.length) {\n\t\treturn {sim: 0};\n\t}\n\treturn cosine(aa, ba);\n}\n\n\nfunction euclideanSets(a: Set<string>, b: Set<string>) {\n\tconst [aa, ba] = extractCommonTargetScores(a, b);\n\tif (!aa.length || !ba.length) {\n\t\treturn {sim: 0};\n\t}\n\treturn euclidean(aa, ba);\n}\n\n\n/**\n *\n * @param a\n * @param b\n */\nfunction pearsonSets(a: Set<string>, b: Set<string>) {\n\tconst [aa, ba, a_mean, b_mean] = extractCommonTargetScores(a, b);\n\n\t// console.log(aa, ba);\n\n\tif (!aa.length || !ba.length) {\n\t\treturn {sim: 0};\n\t}\n\treturn pearson(aa, ba, a_mean, b_mean);\n}\n\n\n/**\n * @description this method implicitly ensures that sets given to cosine\n *              are always of the same length\n * @param a\n * @param b\n */\nfunction extractCommonTargetScores(a: Set<string>, b: Set<string>): [number[], number[], number, number] {\n\t// we need to extract the target IDs first\n\tlet a_id = new Set(), b_id = new Set();\n\tfor (let e of a) a_id.add(e.split('#')[0]);\n\tfor (let e of b) b_id.add(e.split('#')[0]);\n\n\t// now we collect the scores for common targets (in the same order)\n\tlet score, a_map = new Map(), b_map = new Map(), a_vec = [], b_vec = [], earr, a_mean = 0, b_mean = 0;\n\tfor (let e of a) {\n\t\tearr = e.split('#'); // we can assume 0 is the target...\n\t\tscore = +earr[earr.length - 1];\n\t\ta_mean += score;\n\t\tif (b_id.has(earr[0])) {\n\t\t\ta_map.set(earr[0], score);\n\t\t}\n\t}\n\tfor (let e of b) {\n\t\tconst earr = e.split('#');\n\t\tscore = +earr[earr.length - 1];\n\t\tb_mean += score;\n\t\tif (a_id.has(earr[0])) {\n\t\t\tb_map.set(earr[0], score);\n\t\t}\n\t}\n\n\t// Maps preserve the order in which items were entered\n\t// console.log(a_map, b_map);\n\tlet a_keys = Array.from(a_map.keys()).sort();\n\tfor ( let key of a_keys ) {\n\t\ta_vec.push(a_map.get(key));\n\t}\n\tlet b_keys = Array.from(b_map.keys()).sort();\n\tfor ( let key of b_keys ) {\n\t\tb_vec.push(b_map.get(key));\n\t}\n\n\treturn [a_vec, b_vec, a_mean / a.size, b_mean / b.size];\n}\n\n\n","import * as $N from '../core/base/BaseNode';\nimport * as $E from '../core/base/BaseEdge';\nimport * as $G from '../core/base/BaseGraph';\n\nimport * as uuid from 'uuid';\nconst v4 = uuid.v4;\n\n\n/**\n * EITHER generate new edges via specified degree span\n * OR via probability of edge creation from a specified\n * set of nodes to all others\n */\nexport interface NodeDegreeConfiguration {\n\tund_degree?: \t\t \tnumber;\n\tdir_degree?:\t\t \tnumber;\n\tmin_und_degree?: \tnumber;\n\tmax_und_degree?: \tnumber;\n\tmin_dir_degree?: \tnumber;\n\tmax_dir_degree?: \tnumber;\n\tprobability_dir?: number;\n\tprobability_und?: number;\n}\n\n\nexport interface ISimplePerturber {\t\n\t// CREATE EDGES PER NODE\n\tcreateEdgesProb(probability: number, directed?: boolean, setOfNodes?: { [key: string] : $N.IBaseNode} ) : void;\n\tcreateEdgesSpan(min: number, max: number, directed?: boolean, setOfNodes?: { [key: string] : $N.IBaseNode} ) : void;\n\n\t// ADD NODES\n\taddNodesPercentage(percentage: number, config?: NodeDegreeConfiguration ) : void;\n\taddNodesAmount(amount: number, config?: NodeDegreeConfiguration ) : void;\n\n\t// ADD EDGES\n\taddUndEdgesPercentage(percentage: number ) : void;\n\taddDirEdgesPercentage(percentage: number ) : void;\n\taddEdgesAmount(amount: number, config?: $E.BaseEdgeConfig ) : void;\n\n\t// DELETE NODES AND EDGES\n\tdeleteNodesPercentage(percentage: number ) : void;\n\tdeleteUndEdgesPercentage(percentage: number ) : void;\n\tdeleteDirEdgesPercentage(percentage: number ) : void;\n\tdeleteNodesAmount(amount: number ) : void;\n\tdeleteUndEdgesAmount(amount: number ) : void;\n\tdeleteDirEdgesAmount(amount: number ) : void;\n}\n\n\nclass SimplePerturber implements ISimplePerturber {\n\n  constructor(private _graph: $G.IGraph) {}\n\n\t/**\n\t *\n\t * @param percentage\n\t */\n\tdeleteNodesPercentage(percentage: number ) : void {\n\t\tif ( percentage < 0 ) {\n\t\t\tthrow new Error('Cowardly refusing to remove a negative amount of nodes');\n\t\t}\n\t\tif ( percentage > 100 ) {\n\t\t\tpercentage = 100;\n\t\t}\n\t\tlet nr_nodes_to_delete = Math.ceil(this._graph.nrNodes() * percentage/100);\n\t\tthis.deleteNodesAmount( nr_nodes_to_delete );\n\t}\n\n\n\t/**\n\t *\n\t * @param percentage\n\t */\n\tdeleteUndEdgesPercentage(percentage: number ) : void {\n\t\tif ( percentage > 100 ) {\n\t\t\tpercentage = 100;\n\t\t}\n\t\tlet nr_edges_to_delete = Math.ceil(this._graph.nrUndEdges() * percentage/100);\n\t\tthis.deleteUndEdgesAmount( nr_edges_to_delete );\n\t}\n\n\n\t/**\n\t *\n\t * @param percentage\n\t */\n\tdeleteDirEdgesPercentage(percentage: number ) : void {\n\t\tif ( percentage > 100 ) {\n\t\t\tpercentage = 100;\n\t\t}\n\t\tlet nr_edges_to_delete = Math.ceil(this._graph.nrDirEdges() * percentage/100);\n\t\tthis.deleteDirEdgesAmount( nr_edges_to_delete );\n\t}\n\n\n\t/**\n\t * \n\t */\n\tdeleteNodesAmount(amount: number ) : void {\n\t\tif ( amount < 0 ) {\n\t\t\tthrow 'Cowardly refusing to remove a negative amount of nodes';\n\t\t}\n\t\tif ( this._graph.nrNodes() === 0 ) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tfor ( let nodeID = 0, randomNodes = this._graph.pickRandomProperties(this._graph.getNodes(), amount); nodeID < randomNodes.length; nodeID++ ) {\n\t\t\tthis._graph.deleteNode( this._graph.getNodes()[randomNodes[nodeID]] );\n\t\t}\n\t}\n\n\n\t/**\n\t * \n\t */\n\tdeleteUndEdgesAmount(amount: number ) : void {\n\t\tif ( amount < 0 ) {\n\t\t\tthrow 'Cowardly refusing to remove a negative amount of edges';\n\t\t}\n\t\tif ( this._graph.nrUndEdges() === 0 ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor ( let edgeID = 0, randomEdges = this._graph.pickRandomProperties(this._graph.getUndEdges(), amount); edgeID < randomEdges.length; edgeID++ ) {\n\t\t\tthis._graph.deleteEdge( this._graph.getUndEdges()[randomEdges[edgeID]] );\n\t\t}\n\t}\n\n\n\t/**\n\t * \n\t */\n\tdeleteDirEdgesAmount(amount: number ) : void {\n\t\tif ( amount < 0 ) {\n\t\t\tthrow 'Cowardly refusing to remove a negative amount of edges';\n\t\t}\n\t\tif ( this._graph.nrDirEdges() === 0 ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor ( let edgeID = 0, randomEdges = this._graph.pickRandomProperties(this._graph.getDirEdges(), amount); edgeID < randomEdges.length; edgeID++ ) {\n\t\t\tthis._graph.deleteEdge( this._graph.getDirEdges()[randomEdges[edgeID]] );\n\t\t}\n\t}\n\n\n\t/**\n\t *  \n\t */\n\taddUndEdgesPercentage(percentage: number ) : void {\n\t\tlet nr_und_edges_to_add = Math.ceil(this._graph.nrUndEdges() * percentage/100);\t\t\n\t\tthis.addEdgesAmount( nr_und_edges_to_add, {directed: false} );\n\t}\n\n\n\t/**\n\t * \n\t */\n\taddDirEdgesPercentage(percentage: number ) : void {\n\t\tlet nr_dir_edges_to_add = Math.ceil(this._graph.nrDirEdges() * percentage/100);\n\t\tthis.addEdgesAmount( nr_dir_edges_to_add, {directed: true} );\n\t}\n\t\n\t\n\t/**\n\t * \n\t * DEFAULT edge direction: UNDIRECTED\n\t */\n\taddEdgesAmount(amount: number, config?: $E.BaseEdgeConfig ) : void {\n\t\tif ( amount <= 0 ) {\n\t\t\tthrow new Error('Cowardly refusing to add a non-positive amount of edges')\n\t\t}\n\n\t\tlet node_a : $N.IBaseNode,\n\t\t\t\tnode_b : $N.IBaseNode,\n\t\t\t\tnodes\t : {[key: string] : $N.IBaseNode};\n\t\t\n\t\tlet direction = ( config && config.directed ) ? config.directed : false,\n\t\t\t\tdir = direction ? \"_d\" : \"_u\";\n\n\t\t// logger.log(\"DIRECTION of new edges to create: \" + direction ? \"directed\" : \"undirected\");\n\n\t\twhile ( amount > 0 ) {\n\t\t\tnode_a = this._graph.getRandomNode();\n\t\t\twhile ( ( node_b = this._graph.getRandomNode() ) === node_a ) {}\n\n\t\t\tlet edge_id = `${node_a.getID()}_${node_b.getID()}${dir}`;\n\t\t\tif ( node_a.hasEdgeID( edge_id ) ) {\n\t\t\t\t// TODO: Check if the whole duplication prevention is really necessary!\n\t\t\t\t// logger.log(\"Duplicate edge creation, continuing...\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t/**\n\t\t\t\t * Enable random weights for edges ??\n\t\t\t\t */\n\t\t\t\tthis._graph.addEdgeByID(edge_id, node_a, node_b, {directed: direction});\n\t\t\t\t--amount;\n\t\t\t}\n\t\t}\n\n\t\t// logger.log(`Created ${amount} ${direction ? \"directed\" : \"undirected\"} edges...`);\n\t}\n\n\n\t/**\n\t * \n\t */\n\taddNodesPercentage(percentage: number, config?: NodeDegreeConfiguration ) : void {\n\t\tif ( percentage < 0 ) {\n\t\t\tthrow 'Cowardly refusing to add a negative amount of nodes';\n\t\t}\n\t\tlet nr_nodes_to_add = Math.ceil(this._graph.nrNodes() * percentage/100);\n\t\tthis.addNodesAmount( nr_nodes_to_add, config );\n\t}\n\n\n\t/**\n\t * If the degree configuration is invalid\n\t * (negative or infinite degree amount / percentage)\n\t * the nodes will have been created nevertheless\n\t *\n\t * @todo is this `perturbation` since it is not `random` ?\n\t */\n\taddNodesAmount(amount: number, config?: NodeDegreeConfiguration ) : void {\n\t\tif ( amount < 0 ) {\n\t\t\tthrow 'Cowardly refusing to add a negative amount of nodes';\n\t\t}\n\t\tlet new_nodes : { [key: string] : $N.IBaseNode } = {};\n\t\t\n\t\twhile ( --amount >= 0 ) {\n\t\t\tlet new_node_id = v4();\n\t\t\tnew_nodes[new_node_id] = this._graph.addNodeByID( new_node_id );\n\t\t}\n\t\t\n\t\tif ( config == null ) {\n\t\t\treturn;\n\t\t}\n\t\telse {\n\t\t\tthis.createEdgesByConfig( config, new_nodes );\n\t\t}\n\t}\n\t\n\t\n\t/**\n\t * Go through the degree_configuration provided and create edges\n\t * as requested by config\n\t */\n\tprivate createEdgesByConfig( config: NodeDegreeConfiguration, new_nodes: {[key: string] : $N.IBaseNode} ) {\n\t\tlet degree,\n\t\t\t\tmin_degree,\n\t\t\t\tmax_degree,\n\t\t\t\tdeg_probability;\n\t\t\n\t\tif ( config.und_degree != null || \n\t\t\t\t config.dir_degree != null ||\n\t\t\t\t config.min_und_degree != null && config.max_und_degree != null ||\n\t\t\t\t config.min_dir_degree != null && config.max_dir_degree != null )\t\t\n\t\t{\n\t\t\t// Ignore min / max undirected degree if specific amount is given\n\t\t\tif ( ( degree = config.und_degree ) != null ) {\t\t\t\n\t\t\t\tthis.createEdgesSpan(degree, degree, false, new_nodes);\n\t\t\t}\n\t\t\telse if ( ( min_degree = config.min_und_degree) != null \n\t\t\t\t\t\t&& ( max_degree = config.max_und_degree ) != null ) {\n\t\t\t\tthis.createEdgesSpan(min_degree, max_degree, false, new_nodes);\n\t\t\t}\n\t\t\t// Ignore min / max directed degree if specific amount is given\n\t\t\tif ( degree = config.dir_degree ) {\t\t\t\n\t\t\t\tthis.createEdgesSpan(degree, degree, true, new_nodes);\n\t\t\t}\n\t\t\telse if ( ( min_degree = config.min_dir_degree) != null \n\t\t\t\t\t\t&& ( max_degree = config.max_dir_degree ) != null ) {\n\t\t\t\tthis.createEdgesSpan(min_degree, max_degree, true, new_nodes);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif ( config.probability_dir != null ) {\n\t\t\t\tthis.createEdgesProb( config.probability_dir, true, new_nodes );\n\t\t\t}\n\t\t\tif ( config.probability_und != null ) {\n\t\t\t\tthis.createEdgesProb( config.probability_und, false, new_nodes );\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/**\n\t * Simple edge generator:\n\t * Go through all node combinations, and\n\t * add an (un)directed edge with \n\t * @param probability and\n\t * @param directed true or false\n\t * @param new_nodes set of nodes that were added\n\t * CAUTION: this algorithm takes quadratic runtime in #nodes\n\t */\n\tcreateEdgesProb(probability: number, directed?: boolean,\n\t\t\t\t\t\t\t\t\tnew_nodes?: { [key: string] : $N.IBaseNode} ) : void {\n\t\tif (0 > probability || 1 < probability) {\n\t\t\tthrow new Error(\"Probability out of range.\");\n\t\t}\n\t\tdirected = directed || false;\n\t\tnew_nodes = new_nodes || this._graph.getNodes();\n\t\tlet\n\t\t\tall_nodes = this._graph.getNodes(),\n\t\t\t\tnode_a, \n\t\t\t\tnode_b,\n\t\t\t\tedge_id,\n\t\t\t\tdir = directed ? '_d' : '_u';\n\n\t\tfor (node_a in new_nodes) {\n\t\t\tfor (node_b in all_nodes) {\n\t\t\t\tif (node_a !== node_b && Math.random() <= probability) {\n\t\t\t\t\tedge_id = all_nodes[node_a].getID() + \"_\" + all_nodes[node_b].getID() + dir;\n\t\t\t\t\tthis._graph.addEdgeByID(edge_id, all_nodes[node_a], all_nodes[node_b], {directed: directed});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\n\t/**\n\t * Simple edge generator:\n\t * Go through all nodes, and\n\t * add [min, max] (un)directed edges to \n\t * a randomly chosen node\n\t * CAUTION: this algorithm could take quadratic runtime in #nodes\n\t * but should be much faster\n\t */\n\tcreateEdgesSpan(min: number, max: number, directed?: boolean,\n\t\t\t\t\t\t\t\t\tsetOfNodes?: { [key: string] : $N.IBaseNode} ) : void {\n\t\tif (min < 0) {\n\t\t\tthrow new Error('Minimum degree cannot be negative.');\n\t\t}\n\t\tif (max >= this._graph.nrNodes()) {\n\t\t\tthrow new Error('Maximum degree exceeds number of reachable nodes.');\n\t\t}\n\t\tif (min > max) {\n\t\t\tthrow new Error('Minimum degree cannot exceed maximum degree.');\n\t\t}\n\t\tdirected = directed || false;\n\t\t// Do we need to set them integers before the calculations?\n\t\tvar min = min | 0,\n\t\t\t\tmax = max | 0,\n\t\t\t\tnew_nodes = setOfNodes || this._graph.getNodes(),\n\t\t\t\tall_nodes = this._graph.getNodes(),\n\t\t\t\tidx_a,\n\t\t\t\tnode_a,\n\t\t\t\tnode_b,\n\t\t\t\tedge_id,\n\t\t\t\t// we want edges to all possible nodes\n\t\t\t\t// TODO: enhance with types / filters later on\n\t\t\t\tnode_keys = Object.keys(all_nodes),\n\t\t\t\tkeys_len = node_keys.length,\n\t\t\t\trand_idx,\n\t\t\t\trand_deg,\n\t\t\t\tdir = directed ? '_d' : '_u';\n\n\t\tfor (idx_a in new_nodes) {\n\t\t\tnode_a = new_nodes[idx_a];\n\t\t\trand_idx = 0;\n\t\t\trand_deg = (Math.random()*(max-min)+min)|0;\n\t\t\twhile (rand_deg) {\n\t\t\t\trand_idx = (keys_len*Math.random())|0; // should never reach keys_len...\n\t\t\t\tnode_b = all_nodes[node_keys[rand_idx]];\n\t\t\t\tif (node_a !== node_b) {\n\t\t\t\t\tedge_id = node_a.getID() + \"_\" + node_b.getID() + dir;\n\t\t\t\t\t// Check if edge already exists\n\t\t\t\t\tif (node_a.hasEdgeID(edge_id)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tthis._graph.addEdgeByID(edge_id, node_a, node_b, {directed: directed});\n\t\t\t\t\t--rand_deg;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n}\n\nexport {\n  SimplePerturber\n}","import { IGraph, TypedGraph, JSONInput } from 'graphinius';\nimport { IndexConfig, AppConfig } from '../indexers/interfaces';\n\n\nconst jsonIn = new JSONInput({directed: true, explicit_direction: false, weighted: false});\n\n\nasync function importGraph(config: AppConfig) {\n  console.log(`Loading ${config.graphName}...`);\n  let tic = +new Date;\n  const graph: IGraph = await importGraphFromURL(config);\n  let toc = +new Date;\n  console.log(`Importing graph of |V|=${graph.nrNodes()} and |E_dir|=${graph.nrDirEdges()} took ${toc-tic} ms.`);\n  console.log(graph.stats);\n  return graph;\n}\n\n\nasync function importGraphFromURL(config: AppConfig) {\n  const graphBytes = await(await fetch(config.graphFile));\n  const graphString = await graphBytes.json();\n  let graph: IGraph = new TypedGraph(config.graphName);\n  graph = jsonIn.readFromJSON(graphString, graph);\n  window.g = graph;\n  return graph;\n}\n\n\nexport {\n  importGraph\n}\n","import { TypedNode, ITypedNode, TypedGraph, DIR, ExpansionInput, ExpansionResult } from 'graphinius';\nimport { EDGE_TYPES } from \"../../test/datasets/jobs/common\";\n\n\nexport interface TopKConfig {\n  k: number;\n  top: boolean;\n}\n\n\nclass TheExpanse {\n\n  constructor(private _g: TypedGraph) { }\n\n  /**\n   * @description `expand` IDs to ITypedNodes -> 1:1 mapping\n   * @param ids\n   */\n  accumulateNodesFromIDs(ids: string[]): Map<string, ITypedNode> {\n    let result = new Map<string, ITypedNode>();\n    ids.forEach(id => result.set(id, this._g.n(id)));\n    return result;\n  }\n\n\n  /**\n   * @description expand & replace nodes with target nodes, for further expansion\n   *\n   * @example we want to\n   *\n   * @param nodes\n   * @param dir\n   * @param rel\n   *\n   * @todo incorporate frequencies ??\n   *\n   */\n  accumulateNodesFromNodes(nodes: string[] | Set<ITypedNode> | Map<string, ITypedNode>,\n    dir: DIR, rel: EDGE_TYPES): Map<string, ITypedNode> {\n    let result = new Map<string, ITypedNode>();\n    nodes.forEach(node => {\n      let targets;\n      if (typeof node === 'string') {\n        targets = this._g[dir](this._g.n(node), rel);\n      } else {\n        targets = this._g[dir](node, rel);\n      }\n      if (targets) {\n        targets.forEach(t => result.set(t.id, t));\n      }\n    });\n    return result;\n  }\n\n\n  /**\n   * @todo factor in / out / whatever\n   */\n  nodeSetToMap(set: Set<ITypedNode>): Map<string, ITypedNode> {\n    const result = new Map<string, ITypedNode>();\n    set.forEach(el => result.set(el.id, el));\n    return result;\n  }\n\n\n  /**\n   * @description replace a node with a set of target nodes, but keep the original ID\n   *\n   * @example Map<companyID, Company> would be replaced with Map<companyID, Set<Employees>> through the 'WORKS_FOR' relation\n   *          Map<personID, Person> would be replace with Map<personID, Set<Friends>> through the 'KNOWS' relation\n   *\n   * @param nodes either a node type as string or a Map of ITypedNodes\n   * @param dir\n   * @param rel\n   * @returns expansion from a type of nodes or from a set of nodes\n   *\n   * @todo transfer to graphinius (core)?\n   * @todo isn't the `set of nodes` version the same as our normal expander? Except we have a map here...?\n   *       -> where is multiple dispatch when you need it !?\n   */\n  accumulateSetsFromNodes(nodes: string | Map<string, ITypedNode>, dir: DIR, rel: string): { [key: string]: Set<ITypedNode> } {\n    const result: { [key: string]: Set<ITypedNode> } = {};\n    let sourceNodes = typeof nodes === 'string' ? this._g.getNodesT(nodes) : nodes;\n    sourceNodes.forEach(n => {\n      let targets = this._g.expand(n, dir, rel).set;\n      if (targets.size) {\n        result[n.label] = targets;\n      }\n    });\n    return result;\n  }\n\n\n  /**\n   * @description we get a map/dict of Set<ITypedNode>, a direction & a relation\n   *\n   * @example Map<companyID, Set<Employees>> would be replaced with Map<companyID, Set<Countries>> through the 'LIVES_IN' relation\n   *          Map<personID, Set<Friends>> would be replaced with Map<personID, Set<Skills>> through the 'HAS_SKILL' relation\n   *\n   * @returns a object of key : Set<ITypedNode>, where each ex.set is an expansion of one input Set\n   *\n   * @todo this should give back sets with frequencies, so ExpansionResult objects\n   */\n  accumulateSetsFromSets(sources: { [key: string]: Set<ITypedNode> }, dir: DIR, rel: string): { [key: string]: Set<ITypedNode> } {\n    const result: { [key: string]: Set<ITypedNode> } = {};\n    const keys = Object.keys(sources);\n    for (let i of keys) {\n      for (let source of sources[i]) {\n        if (!result[i]) {\n          result[i] = new Set<ITypedNode>();\n        }\n        let targets = this._g.expand(source, dir, rel);\n        if (!targets) {\n          continue;\n        }\n        for (let target of targets.set) {\n          result[i].add(target);\n        }\n      }\n    }\n    return result;\n  }\n\n\n  /**\n   * @todo figure out how often we'll need that & test it !!!\n   *\n   * @param sources\n   * @param dir\n   * @param rel\n   */\n  accumulateSetsFromSetsFreq(sources: { [key: string]: ExpansionInput }, dir: DIR, rel: string): { [key: string]: ExpansionResult } {\n    const result: { [key: string]: ExpansionResult } = {};\n    const keys = Object.keys(sources);\n\n    for (let i of keys) {\n      if (!result[i]) {\n        result[i] = { set: new Set<ITypedNode>(), freq: new Map<ITypedNode, number>() };\n      }\n      let res = result[i];\n      // convert each ExpansionInput into a properly formatted object\n      const input_i = TypedGraph.convertToExpansionResult(sources[i]);\n\n      // iterate over the set only? => Why not, it's delivering ITypedNodes\n      // which simultaneously are the keys in the freq Map\n      for (let source of input_i.set) {\n        let targets = this._g.expand(source, dir, rel);\n        if (!targets.set.size) {\n          continue;\n        }\n        for (let nodeRef of targets.set) {\n          if (!res.freq.has(nodeRef)) {\n            res.freq.set(nodeRef, targets.freq.get(nodeRef));\n          }\n          if (res.set.has(nodeRef)) {\n            res.freq.set(nodeRef, res.freq.get(nodeRef) + targets.freq.get(nodeRef));\n          }\n          res.set.add(nodeRef);\n        }\n      }\n    }\n    return result;\n  }\n\n\n  /**\n   *\n   * @param obj\n   * @param cfg\n   */\n  setFromSetsTopK(obj: { [key: string]: ExpansionResult }, cfg: TopKConfig = { k: 5, top: true }): { [key: string]: ExpansionResult } {\n    const sortFunc = cfg.top ? (a, b) => b[1] - a[1] : (a, b) => a[1] - b[1];\n    const result: { [key: string]: ExpansionResult } = {};\n    for (let [id, e] of Object.entries(obj)) {\n      result[id] = { set: new Set<ITypedNode>(), freq: new Map<ITypedNode, number>() };\n      result[id].freq = new Map([...e.freq.entries()].sort(sortFunc).slice(0, cfg.k));\n      result[id].set = new Set([...result[id].freq.keys()]);\n    }\n    return result;\n  }\n\n\n  /**\n   * @description get a readable version of a SetFromSetsFreq object\n   *\n   * @param obj\n   * @param idName\n   * @param collectionName\n   * @param itemName\n   *\n   * @returns object with source name & a list of plain item names with item frequencies\n   *\n   * @todo specify return value\n   */\n  readableSetsFromSetsFreq(obj: { [key: string]: ExpansionResult }, idName: string, collectionName: string, itemName: string) {\n    return Object.entries(obj).map(e => ({\n      [idName]: this._g.n(e[0]).f('name'),\n      [collectionName]: Array.from(e[1].freq).map(v => ({ freq: v[1], [itemName]: v[0].f('name') }))\n    }));\n  }\n\n\n}\n\n\nexport {\n  TheExpanse\n}\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Indexes for all substring searches (e.g. the term \"cat\" is indexed as \"c\", \"ca\", \"cat\", \"a\", \"at\", and \"t\").\n */\nvar AllSubstringsIndexStrategy = exports.AllSubstringsIndexStrategy = function () {\n  function AllSubstringsIndexStrategy() {\n    _classCallCheck(this, AllSubstringsIndexStrategy);\n  }\n\n  _createClass(AllSubstringsIndexStrategy, [{\n    key: 'expandToken',\n\n\n    /**\n     * @inheritDocs\n     */\n    value: function expandToken(token) {\n      var expandedTokens = [];\n      var string;\n\n      for (var i = 0, length = token.length; i < length; ++i) {\n        string = '';\n\n        for (var j = i; j < length; ++j) {\n          string += token.charAt(j);\n          expandedTokens.push(string);\n        }\n      }\n\n      return expandedTokens;\n    }\n  }]);\n\n  return AllSubstringsIndexStrategy;\n}();\n\n;\n//# sourceMappingURL=AllSubstringsIndexStrategy.js.map","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Indexes for exact word matches.\n */\nvar ExactWordIndexStrategy = exports.ExactWordIndexStrategy = function () {\n  function ExactWordIndexStrategy() {\n    _classCallCheck(this, ExactWordIndexStrategy);\n  }\n\n  _createClass(ExactWordIndexStrategy, [{\n    key: 'expandToken',\n\n\n    /**\n     * @inheritDocs\n     */\n    value: function expandToken(token) {\n      return token ? [token] : [];\n    }\n  }]);\n\n  return ExactWordIndexStrategy;\n}();\n\n;\n//# sourceMappingURL=ExactWordIndexStrategy.js.map","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Indexes for prefix searches (e.g. the term \"cat\" is indexed as \"c\", \"ca\", and \"cat\" allowing prefix search lookups).\n */\nvar PrefixIndexStrategy = exports.PrefixIndexStrategy = function () {\n  function PrefixIndexStrategy() {\n    _classCallCheck(this, PrefixIndexStrategy);\n  }\n\n  _createClass(PrefixIndexStrategy, [{\n    key: 'expandToken',\n\n\n    /**\n     * @inheritDocs\n     */\n    value: function expandToken(token) {\n      var expandedTokens = [];\n      var string = '';\n\n      for (var i = 0, length = token.length; i < length; ++i) {\n        string += token.charAt(i);\n        expandedTokens.push(string);\n      }\n\n      return expandedTokens;\n    }\n  }]);\n\n  return PrefixIndexStrategy;\n}();\n\n;\n//# sourceMappingURL=PrefixIndexStrategy.js.map","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _AllSubstringsIndexStrategy = require('./AllSubstringsIndexStrategy');\n\nObject.defineProperty(exports, 'AllSubstringsIndexStrategy', {\n  enumerable: true,\n  get: function get() {\n    return _AllSubstringsIndexStrategy.AllSubstringsIndexStrategy;\n  }\n});\n\nvar _ExactWordIndexStrategy = require('./ExactWordIndexStrategy');\n\nObject.defineProperty(exports, 'ExactWordIndexStrategy', {\n  enumerable: true,\n  get: function get() {\n    return _ExactWordIndexStrategy.ExactWordIndexStrategy;\n  }\n});\n\nvar _PrefixIndexStrategy = require('./PrefixIndexStrategy');\n\nObject.defineProperty(exports, 'PrefixIndexStrategy', {\n  enumerable: true,\n  get: function get() {\n    return _PrefixIndexStrategy.PrefixIndexStrategy;\n  }\n});\n//# sourceMappingURL=index.js.map","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Enforces case-sensitive text matches.\n */\nvar CaseSensitiveSanitizer = exports.CaseSensitiveSanitizer = function () {\n  function CaseSensitiveSanitizer() {\n    _classCallCheck(this, CaseSensitiveSanitizer);\n  }\n\n  _createClass(CaseSensitiveSanitizer, [{\n    key: 'sanitize',\n\n\n    /**\n     * @inheritDocs\n     */\n    value: function sanitize(text) {\n      return text ? text.trim() : '';\n    }\n  }]);\n\n  return CaseSensitiveSanitizer;\n}();\n\n;\n//# sourceMappingURL=CaseSensitiveSanitizer.js.map","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Sanitizes text by converting to a locale-friendly lower-case version and triming leading and trailing whitespace.\n */\nvar LowerCaseSanitizer = exports.LowerCaseSanitizer = function () {\n  function LowerCaseSanitizer() {\n    _classCallCheck(this, LowerCaseSanitizer);\n  }\n\n  _createClass(LowerCaseSanitizer, [{\n    key: 'sanitize',\n\n\n    /**\n     * @inheritDocs\n     */\n    value: function sanitize(text) {\n      return text ? text.toLocaleLowerCase().trim() : '';\n    }\n  }]);\n\n  return LowerCaseSanitizer;\n}();\n\n;\n//# sourceMappingURL=LowerCaseSanitizer.js.map","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _CaseSensitiveSanitizer = require('./CaseSensitiveSanitizer');\n\nObject.defineProperty(exports, 'CaseSensitiveSanitizer', {\n  enumerable: true,\n  get: function get() {\n    return _CaseSensitiveSanitizer.CaseSensitiveSanitizer;\n  }\n});\n\nvar _LowerCaseSanitizer = require('./LowerCaseSanitizer');\n\nObject.defineProperty(exports, 'LowerCaseSanitizer', {\n  enumerable: true,\n  get: function get() {\n    return _LowerCaseSanitizer.LowerCaseSanitizer;\n  }\n});\n//# sourceMappingURL=index.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = getNestedFieldValue;\n/**\n * Find and return a nested object value.\n *\n * @param object to crawl\n * @param path Property path\n * @returns {any}\n */\nfunction getNestedFieldValue(object, path) {\n  path = path || [];\n  object = object || {};\n\n  var value = object;\n\n  // walk down the property path\n  for (var i = 0; i < path.length; i++) {\n    value = value[path[i]];\n\n    if (value == null) {\n      return null;\n    }\n  }\n\n  return value;\n}\n//# sourceMappingURL=getNestedFieldValue.js.map","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TfIdfSearchIndex = undefined;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _getNestedFieldValue = require('../getNestedFieldValue');\n\nvar _getNestedFieldValue2 = _interopRequireDefault(_getNestedFieldValue);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Search index capable of returning results matching a set of tokens and ranked according to TF-IDF.\n */\nvar TfIdfSearchIndex = exports.TfIdfSearchIndex = function () {\n  function TfIdfSearchIndex(uidFieldName) {\n    _classCallCheck(this, TfIdfSearchIndex);\n\n    this._uidFieldName = uidFieldName;\n    this._tokenToIdfCache = {};\n    this._tokenMap = {};\n  }\n\n  /**\n   * @inheritDocs\n   */\n\n\n  _createClass(TfIdfSearchIndex, [{\n    key: 'indexDocument',\n    value: function indexDocument(token, uid, doc) {\n      this._tokenToIdfCache = {}; // New index invalidates previous IDF caches\n\n      var tokenMap = this._tokenMap;\n      var tokenDatum;\n\n      if (_typeof(tokenMap[token]) !== 'object') {\n        tokenMap[token] = tokenDatum = {\n          $numDocumentOccurrences: 0,\n          $totalNumOccurrences: 1,\n          $uidMap: {}\n        };\n      } else {\n        tokenDatum = tokenMap[token];\n        tokenDatum.$totalNumOccurrences++;\n      }\n\n      var uidMap = tokenDatum.$uidMap;\n\n      if (_typeof(uidMap[uid]) !== 'object') {\n        tokenDatum.$numDocumentOccurrences++;\n        uidMap[uid] = {\n          $document: doc,\n          $numTokenOccurrences: 1\n        };\n      } else {\n        uidMap[uid].$numTokenOccurrences++;\n      }\n    }\n\n    /**\n     * @inheritDocs\n     */\n\n  }, {\n    key: 'search',\n    value: function search(tokens, corpus) {\n      var uidToDocumentMap = {};\n\n      for (var i = 0, numTokens = tokens.length; i < numTokens; i++) {\n        var token = tokens[i];\n        var tokenMetadata = this._tokenMap[token];\n\n        // Short circuit if no matches were found for any given token.\n        if (!tokenMetadata) {\n          return [];\n        }\n\n        if (i === 0) {\n          var keys = Object.keys(tokenMetadata.$uidMap);\n          for (var j = 0, numKeys = keys.length; j < numKeys; j++) {\n            var uid = keys[j];\n\n            uidToDocumentMap[uid] = tokenMetadata.$uidMap[uid].$document;\n          }\n        } else {\n          var keys = Object.keys(uidToDocumentMap);\n          for (var j = 0, numKeys = keys.length; j < numKeys; j++) {\n            var uid = keys[j];\n\n            if (_typeof(tokenMetadata.$uidMap[uid]) !== 'object') {\n              delete uidToDocumentMap[uid];\n            }\n          }\n        }\n      }\n\n      var documents = [];\n\n      for (var uid in uidToDocumentMap) {\n        documents.push(uidToDocumentMap[uid]);\n      }\n\n      var calculateTfIdf = this._createCalculateTfIdf();\n\n      // Return documents sorted by TF-IDF\n      return documents.sort(function (documentA, documentB) {\n        return calculateTfIdf(tokens, documentB, corpus) - calculateTfIdf(tokens, documentA, corpus);\n      });\n    }\n  }, {\n    key: '_createCalculateIdf',\n    value: function _createCalculateIdf() {\n      var tokenMap = this._tokenMap;\n      var tokenToIdfCache = this._tokenToIdfCache;\n\n      return function calculateIdf(token, documents) {\n        if (!tokenToIdfCache[token]) {\n          var numDocumentsWithToken = typeof tokenMap[token] !== 'undefined' ? tokenMap[token].$numDocumentOccurrences : 0;\n\n          tokenToIdfCache[token] = 1 + Math.log(documents.length / (1 + numDocumentsWithToken));\n        }\n\n        return tokenToIdfCache[token];\n      };\n    }\n  }, {\n    key: '_createCalculateTfIdf',\n    value: function _createCalculateTfIdf() {\n      var tokenMap = this._tokenMap;\n      var uidFieldName = this._uidFieldName;\n      var calculateIdf = this._createCalculateIdf();\n\n      return function calculateTfIdf(tokens, document, documents) {\n        var score = 0;\n\n        for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {\n          var token = tokens[i];\n\n          var inverseDocumentFrequency = calculateIdf(token, documents);\n\n          if (inverseDocumentFrequency === Infinity) {\n            inverseDocumentFrequency = 0;\n          }\n\n          var uid;\n          if (uidFieldName instanceof Array) {\n            uid = document && (0, _getNestedFieldValue2.default)(document, uidFieldName);\n          } else {\n            uid = document && document[uidFieldName];\n          }\n\n          var termFrequency = typeof tokenMap[token] !== 'undefined' && typeof tokenMap[token].$uidMap[uid] !== 'undefined' ? tokenMap[token].$uidMap[uid].$numTokenOccurrences : 0;\n\n          score += termFrequency * inverseDocumentFrequency;\n        }\n\n        return score;\n      };\n    }\n  }]);\n\n  return TfIdfSearchIndex;\n}();\n\n;\n//# sourceMappingURL=TfIdfSearchIndex.js.map","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Search index capable of returning results matching a set of tokens but without any meaningful rank or order.\n */\nvar UnorderedSearchIndex = exports.UnorderedSearchIndex = function () {\n  function UnorderedSearchIndex() {\n    _classCallCheck(this, UnorderedSearchIndex);\n\n    this._tokenToUidToDocumentMap = {};\n  }\n\n  /**\n   * @inheritDocs\n   */\n\n\n  _createClass(UnorderedSearchIndex, [{\n    key: 'indexDocument',\n    value: function indexDocument(token, uid, doc) {\n      if (_typeof(this._tokenToUidToDocumentMap[token]) !== 'object') {\n        this._tokenToUidToDocumentMap[token] = {};\n      }\n\n      this._tokenToUidToDocumentMap[token][uid] = doc;\n    }\n\n    /**\n     * @inheritDocs\n     */\n\n  }, {\n    key: 'search',\n    value: function search(tokens, corpus) {\n      var intersectingDocumentMap = {};\n\n      var tokenToUidToDocumentMap = this._tokenToUidToDocumentMap;\n\n      for (var i = 0, numTokens = tokens.length; i < numTokens; i++) {\n        var token = tokens[i];\n        var documentMap = tokenToUidToDocumentMap[token];\n\n        // Short circuit if no matches were found for any given token.\n        if (!documentMap) {\n          return [];\n        }\n\n        if (i === 0) {\n          var keys = Object.keys(documentMap);\n\n          for (var j = 0, numKeys = keys.length; j < numKeys; j++) {\n            var uid = keys[j];\n\n            intersectingDocumentMap[uid] = documentMap[uid];\n          }\n        } else {\n          var keys = Object.keys(intersectingDocumentMap);\n\n          for (var j = 0, numKeys = keys.length; j < numKeys; j++) {\n            var uid = keys[j];\n\n            if (_typeof(documentMap[uid]) !== 'object') {\n              delete intersectingDocumentMap[uid];\n            }\n          }\n        }\n      }\n\n      var keys = Object.keys(intersectingDocumentMap);\n      var documents = [];\n\n      for (var i = 0, numKeys = keys.length; i < numKeys; i++) {\n        var uid = keys[i];\n\n        documents.push(intersectingDocumentMap[uid]);\n      }\n\n      return documents;\n    }\n  }]);\n\n  return UnorderedSearchIndex;\n}();\n\n;\n//# sourceMappingURL=UnorderedSearchIndex.js.map","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _TfIdfSearchIndex = require('./TfIdfSearchIndex');\n\nObject.defineProperty(exports, 'TfIdfSearchIndex', {\n  enumerable: true,\n  get: function get() {\n    return _TfIdfSearchIndex.TfIdfSearchIndex;\n  }\n});\n\nvar _UnorderedSearchIndex = require('./UnorderedSearchIndex');\n\nObject.defineProperty(exports, 'UnorderedSearchIndex', {\n  enumerable: true,\n  get: function get() {\n    return _UnorderedSearchIndex.UnorderedSearchIndex;\n  }\n});\n//# sourceMappingURL=index.js.map","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar REGEX = /[^a-z-0-9\\-']+/i;\n\n/**\n * Simple tokenizer that splits strings on whitespace characters and returns an array of all non-empty substrings.\n */\n\n\nvar SimpleTokenizer = exports.SimpleTokenizer = function () {\n  function SimpleTokenizer() {\n    _classCallCheck(this, SimpleTokenizer);\n  }\n\n  _createClass(SimpleTokenizer, [{\n    key: 'tokenize',\n\n\n    /**\n     * @inheritDocs\n     */\n    value: function tokenize(text) {\n      return text.split(REGEX).filter(function (text) {\n        return text;\n      } // Filter empty tokens\n      );\n    }\n  }]);\n\n  return SimpleTokenizer;\n}();\n\n;\n//# sourceMappingURL=SimpleTokenizer.js.map","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Stemming is the process of reducing search tokens to their root (or stem) so that searches for different forms of a\n * word will match. For example \"search\", \"searching\" and \"searched\" are all reduced to the stem \"search\".\n *\n * <p>This stemming tokenizer converts tokens (words) to their stem forms before returning them. It requires an\n * external stemming function to be provided; for this purpose I recommend the NPM 'porter-stemmer' library.\n *\n * <p>For more information see http : //tartarus.org/~martin/PorterStemmer/\n */\nvar StemmingTokenizer = exports.StemmingTokenizer = function () {\n\n  /**\n   * Constructor.\n   *\n   * @param stemmingFunction Function capable of accepting a word and returning its stem.\n   * @param decoratedIndexStrategy Index strategy to be run after all stop words have been removed.\n   */\n  function StemmingTokenizer(stemmingFunction, decoratedTokenizer) {\n    _classCallCheck(this, StemmingTokenizer);\n\n    this._stemmingFunction = stemmingFunction;\n    this._tokenizer = decoratedTokenizer;\n  }\n\n  /**\n   * @inheritDocs\n   */\n\n\n  _createClass(StemmingTokenizer, [{\n    key: 'tokenize',\n    value: function tokenize(text) {\n      return this._tokenizer.tokenize(text).map(this._stemmingFunction);\n    }\n  }]);\n\n  return StemmingTokenizer;\n}();\n\n;\n//# sourceMappingURL=StemmingTokenizer.js.map","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar StopWordsMap = exports.StopWordsMap = {\n  a: true,\n  able: true,\n  about: true,\n  across: true,\n  after: true,\n  all: true,\n  almost: true,\n  also: true,\n  am: true,\n  among: true,\n  an: true,\n  and: true,\n  any: true,\n  are: true,\n  as: true,\n  at: true,\n  be: true,\n  because: true,\n  been: true,\n  but: true,\n  by: true,\n  can: true,\n  cannot: true,\n  could: true,\n  dear: true,\n  did: true,\n  'do': true,\n  does: true,\n  either: true,\n  'else': true,\n  ever: true,\n  every: true,\n  'for': true,\n  from: true,\n  'get': true,\n  got: true,\n  had: true,\n  has: true,\n  have: true,\n  he: true,\n  her: true,\n  hers: true,\n  him: true,\n  his: true,\n  how: true,\n  however: true,\n  i: true,\n  'if': true,\n  'in': true,\n  into: true,\n  is: true,\n  it: true,\n  its: true,\n  just: true,\n  least: true,\n  let: true,\n  like: true,\n  likely: true,\n  may: true,\n  me: true,\n  might: true,\n  most: true,\n  must: true,\n  my: true,\n  neither: true,\n  no: true,\n  nor: true,\n  not: true,\n  of: true,\n  off: true,\n  often: true,\n  on: true,\n  only: true,\n  or: true,\n  other: true,\n  our: true,\n  own: true,\n  rather: true,\n  said: true,\n  say: true,\n  says: true,\n  she: true,\n  should: true,\n  since: true,\n  so: true,\n  some: true,\n  than: true,\n  that: true,\n  the: true,\n  their: true,\n  them: true,\n  then: true,\n  there: true,\n  these: true,\n  they: true,\n  'this': true,\n  tis: true,\n  to: true,\n  too: true,\n  twas: true,\n  us: true,\n  wants: true,\n  was: true,\n  we: true,\n  were: true,\n  what: true,\n  when: true,\n  where: true,\n  which: true,\n  'while': true,\n  who: true,\n  whom: true,\n  why: true,\n  will: true,\n  'with': true,\n  would: true,\n  yet: true,\n  you: true,\n  your: true\n};\n\n// Prevent false positives for inherited properties\nStopWordsMap.constructor = false;\nStopWordsMap.hasOwnProperty = false;\nStopWordsMap.isPrototypeOf = false;\nStopWordsMap.propertyIsEnumerable = false;\nStopWordsMap.toLocaleString = false;\nStopWordsMap.toString = false;\nStopWordsMap.valueOf = false;\n//# sourceMappingURL=StopWordsMap.js.map","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.StopWordsTokenizer = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _StopWordsMap = require('../StopWordsMap');\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Stop words are very common (e.g. \"a\", \"and\", \"the\") and are often not semantically meaningful in the context of a\n * search. This tokenizer removes stop words from a set of tokens before passing the remaining tokens along for\n * indexing or searching purposes.\n */\nvar StopWordsTokenizer = exports.StopWordsTokenizer = function () {\n\n  /**\n   * Constructor.\n   *\n   * @param decoratedIndexStrategy Index strategy to be run after all stop words have been removed.\n   */\n  function StopWordsTokenizer(decoratedTokenizer) {\n    _classCallCheck(this, StopWordsTokenizer);\n\n    this._tokenizer = decoratedTokenizer;\n  }\n\n  /**\n   * @inheritDocs\n   */\n\n\n  _createClass(StopWordsTokenizer, [{\n    key: 'tokenize',\n    value: function tokenize(text) {\n      return this._tokenizer.tokenize(text).filter(function (token) {\n        return !_StopWordsMap.StopWordsMap[token];\n      });\n    }\n  }]);\n\n  return StopWordsTokenizer;\n}();\n\n;\n//# sourceMappingURL=StopWordsTokenizer.js.map","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _SimpleTokenizer = require('./SimpleTokenizer');\n\nObject.defineProperty(exports, 'SimpleTokenizer', {\n  enumerable: true,\n  get: function get() {\n    return _SimpleTokenizer.SimpleTokenizer;\n  }\n});\n\nvar _StemmingTokenizer = require('./StemmingTokenizer');\n\nObject.defineProperty(exports, 'StemmingTokenizer', {\n  enumerable: true,\n  get: function get() {\n    return _StemmingTokenizer.StemmingTokenizer;\n  }\n});\n\nvar _StopWordsTokenizer = require('./StopWordsTokenizer');\n\nObject.defineProperty(exports, 'StopWordsTokenizer', {\n  enumerable: true,\n  get: function get() {\n    return _StopWordsTokenizer.StopWordsTokenizer;\n  }\n});\n//# sourceMappingURL=index.js.map","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Search = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _getNestedFieldValue = require('./getNestedFieldValue');\n\nvar _getNestedFieldValue2 = _interopRequireDefault(_getNestedFieldValue);\n\nvar _index = require('./IndexStrategy/index');\n\nvar _index2 = require('./Sanitizer/index');\n\nvar _index3 = require('./SearchIndex/index');\n\nvar _index4 = require('./Tokenizer/index');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Simple client-side searching within a set of documents.\n *\n * <p>Documents can be searched by any number of fields. Indexing and search strategies are highly customizable.\n */\nvar Search = exports.Search = function () {\n\n  /**\n   * Constructor.\n   * @param uidFieldName Field containing values that uniquely identify search documents; this field's values are used\n   *                     to ensure that a search result set does not contain duplicate objects.\n   */\n\n\n  /**\n   * Array containing either a property name or a path (list of property names) to a nested value\n   */\n  function Search(uidFieldName) {\n    _classCallCheck(this, Search);\n\n    if (!uidFieldName) {\n      throw Error('js-search requires a uid field name constructor parameter');\n    }\n\n    this._uidFieldName = uidFieldName;\n\n    // Set default/recommended strategies\n    this._indexStrategy = new _index.PrefixIndexStrategy();\n    this._searchIndex = new _index3.TfIdfSearchIndex(uidFieldName);\n    this._sanitizer = new _index2.LowerCaseSanitizer();\n    this._tokenizer = new _index4.SimpleTokenizer();\n\n    this._documents = [];\n    this._searchableFields = [];\n  }\n\n  /**\n   * Override the default index strategy.\n   * @param value Custom index strategy\n   * @throws Error if documents have already been indexed by this search instance\n   */\n\n\n  _createClass(Search, [{\n    key: 'addDocument',\n\n\n    /**\n     * Add a searchable document to the index. Document will automatically be indexed for search.\n     * @param document\n     */\n    value: function addDocument(document) {\n      this.addDocuments([document]);\n    }\n\n    /**\n     * Adds searchable documents to the index. Documents will automatically be indexed for search.\n     * @param document\n     */\n\n  }, {\n    key: 'addDocuments',\n    value: function addDocuments(documents) {\n      this._documents = this._documents.concat(documents);\n      this.indexDocuments_(documents, this._searchableFields);\n    }\n\n    /**\n     * Add a new searchable field to the index. Existing documents will automatically be indexed using this new field.\n     *\n     * @param field Searchable field or field path. Pass a string to index a top-level field and an array of strings for nested fields.\n     */\n\n  }, {\n    key: 'addIndex',\n    value: function addIndex(field) {\n      this._searchableFields.push(field);\n      this.indexDocuments_(this._documents, [field]);\n    }\n\n    /**\n     * Search all documents for ones matching the specified query text.\n     * @param query\n     * @returns {Array<Object>}\n     */\n\n  }, {\n    key: 'search',\n    value: function search(query) {\n      var tokens = this._tokenizer.tokenize(this._sanitizer.sanitize(query));\n\n      return this._searchIndex.search(tokens, this._documents);\n    }\n\n    /**\n     * @param documents\n     * @param _searchableFields Array containing property names and paths (lists of property names) to nested values\n     * @private\n     */\n\n  }, {\n    key: 'indexDocuments_',\n    value: function indexDocuments_(documents, _searchableFields) {\n      this._initialized = true;\n\n      var indexStrategy = this._indexStrategy;\n      var sanitizer = this._sanitizer;\n      var searchIndex = this._searchIndex;\n      var tokenizer = this._tokenizer;\n      var uidFieldName = this._uidFieldName;\n\n      for (var di = 0, numDocuments = documents.length; di < numDocuments; di++) {\n        var doc = documents[di];\n        var uid;\n\n        if (uidFieldName instanceof Array) {\n          uid = (0, _getNestedFieldValue2.default)(doc, uidFieldName);\n        } else {\n          uid = doc[uidFieldName];\n        }\n\n        for (var sfi = 0, numSearchableFields = _searchableFields.length; sfi < numSearchableFields; sfi++) {\n          var fieldValue;\n          var searchableField = _searchableFields[sfi];\n\n          if (searchableField instanceof Array) {\n            fieldValue = (0, _getNestedFieldValue2.default)(doc, searchableField);\n          } else {\n            fieldValue = doc[searchableField];\n          }\n\n          if (fieldValue != null && typeof fieldValue !== 'string' && fieldValue.toString) {\n            fieldValue = fieldValue.toString();\n          }\n\n          if (typeof fieldValue === 'string') {\n            var fieldTokens = tokenizer.tokenize(sanitizer.sanitize(fieldValue));\n\n            for (var fti = 0, numFieldValues = fieldTokens.length; fti < numFieldValues; fti++) {\n              var fieldToken = fieldTokens[fti];\n              var expandedTokens = indexStrategy.expandToken(fieldToken);\n\n              for (var eti = 0, nummExpandedTokens = expandedTokens.length; eti < nummExpandedTokens; eti++) {\n                var expandedToken = expandedTokens[eti];\n\n                searchIndex.indexDocument(expandedToken, uid, doc);\n              }\n            }\n          }\n        }\n      }\n    }\n  }, {\n    key: 'indexStrategy',\n    set: function set(value) {\n      if (this._initialized) {\n        throw Error('IIndexStrategy cannot be set after initialization');\n      }\n\n      this._indexStrategy = value;\n    },\n    get: function get() {\n      return this._indexStrategy;\n    }\n\n    /**\n     * Override the default text sanitizing strategy.\n     * @param value Custom text sanitizing strategy\n     * @throws Error if documents have already been indexed by this search instance\n     */\n\n  }, {\n    key: 'sanitizer',\n    set: function set(value) {\n      if (this._initialized) {\n        throw Error('ISanitizer cannot be set after initialization');\n      }\n\n      this._sanitizer = value;\n    },\n    get: function get() {\n      return this._sanitizer;\n    }\n\n    /**\n     * Override the default search index strategy.\n     * @param value Custom search index strategy\n     * @throws Error if documents have already been indexed\n     */\n\n  }, {\n    key: 'searchIndex',\n    set: function set(value) {\n      if (this._initialized) {\n        throw Error('ISearchIndex cannot be set after initialization');\n      }\n\n      this._searchIndex = value;\n    },\n    get: function get() {\n      return this._searchIndex;\n    }\n\n    /**\n     * Override the default text tokenizing strategy.\n     * @param value Custom text tokenizing strategy\n     * @throws Error if documents have already been indexed by this search instance\n     */\n\n  }, {\n    key: 'tokenizer',\n    set: function set(value) {\n      if (this._initialized) {\n        throw Error('ITokenizer cannot be set after initialization');\n      }\n\n      this._tokenizer = value;\n    },\n    get: function get() {\n      return this._tokenizer;\n    }\n  }]);\n\n  return Search;\n}();\n//# sourceMappingURL=Search.js.map","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TokenHighlighter = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _index = require('./IndexStrategy/index');\n\nvar _index2 = require('./Sanitizer/index');\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * This utility highlights the occurrences of tokens within a string of text. It can be used to give visual indicators\n * of match criteria within searchable fields.\n *\n * <p>For performance purposes this highlighter only works with full-word or prefix token indexes.\n */\nvar TokenHighlighter = exports.TokenHighlighter = function () {\n\n  /**\n   * Constructor.\n   *\n   * @param opt_indexStrategy Index strategy used by Search\n   * @param opt_sanitizer Sanitizer used by Search\n   * @param opt_wrapperTagName Optional wrapper tag name; defaults to 'mark' (e.g. <mark>)\n   */\n  function TokenHighlighter(opt_indexStrategy, opt_sanitizer, opt_wrapperTagName) {\n    _classCallCheck(this, TokenHighlighter);\n\n    this._indexStrategy = opt_indexStrategy || new _index.PrefixIndexStrategy();\n    this._sanitizer = opt_sanitizer || new _index2.LowerCaseSanitizer();\n    this._wrapperTagName = opt_wrapperTagName || 'mark';\n  }\n\n  /**\n   * Highlights token occurrences within a string by wrapping them with a DOM element.\n   *\n   * @param text e.g. \"john wayne\"\n   * @param tokens e.g. [\"wa\"]\n   * @returns {string} e.g. \"john <mark>wa</mark>yne\"\n   */\n\n\n  _createClass(TokenHighlighter, [{\n    key: 'highlight',\n    value: function highlight(text, tokens) {\n      var tagsLength = this._wrapText('').length;\n\n      var tokenDictionary = Object.create(null);\n\n      // Create a token map for easier lookup below.\n      for (var i = 0, numTokens = tokens.length; i < numTokens; i++) {\n        var token = this._sanitizer.sanitize(tokens[i]);\n        var expandedTokens = this._indexStrategy.expandToken(token);\n\n        for (var j = 0, numExpandedTokens = expandedTokens.length; j < numExpandedTokens; j++) {\n          var expandedToken = expandedTokens[j];\n\n          if (!tokenDictionary[expandedToken]) {\n            tokenDictionary[expandedToken] = [token];\n          } else {\n            tokenDictionary[expandedToken].push(token);\n          }\n        }\n      }\n\n      // Track actualCurrentWord and sanitizedCurrentWord separately in case we encounter nested tags.\n      var actualCurrentWord = '';\n      var sanitizedCurrentWord = '';\n      var currentWordStartIndex = 0;\n\n      // Note this assumes either prefix or full word matching.\n      for (var i = 0, textLength = text.length; i < textLength; i++) {\n        var character = text.charAt(i);\n\n        if (character === ' ') {\n          actualCurrentWord = '';\n          sanitizedCurrentWord = '';\n          currentWordStartIndex = i + 1;\n        } else {\n          actualCurrentWord += character;\n          sanitizedCurrentWord += this._sanitizer.sanitize(character);\n        }\n\n        if (tokenDictionary[sanitizedCurrentWord] && tokenDictionary[sanitizedCurrentWord].indexOf(sanitizedCurrentWord) >= 0) {\n\n          actualCurrentWord = this._wrapText(actualCurrentWord);\n          text = text.substring(0, currentWordStartIndex) + actualCurrentWord + text.substring(i + 1);\n\n          i += tagsLength;\n          textLength += tagsLength;\n        }\n      }\n\n      return text;\n    }\n\n    /**\n     * @param text to wrap\n     * @returns Text wrapped by wrapper tag (e.g. \"foo\" becomes \"<mark>foo</mark>\")\n     * @private\n     */\n\n  }, {\n    key: '_wrapText',\n    value: function _wrapText(text) {\n      var tagName = this._wrapperTagName;\n      return '<' + tagName + '>' + text + '</' + tagName + '>';\n    }\n  }]);\n\n  return TokenHighlighter;\n}();\n\n;\n//# sourceMappingURL=TokenHighlighter.js.map","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _index = require('./IndexStrategy/index');\n\nObject.defineProperty(exports, 'AllSubstringsIndexStrategy', {\n  enumerable: true,\n  get: function get() {\n    return _index.AllSubstringsIndexStrategy;\n  }\n});\nObject.defineProperty(exports, 'ExactWordIndexStrategy', {\n  enumerable: true,\n  get: function get() {\n    return _index.ExactWordIndexStrategy;\n  }\n});\nObject.defineProperty(exports, 'PrefixIndexStrategy', {\n  enumerable: true,\n  get: function get() {\n    return _index.PrefixIndexStrategy;\n  }\n});\n\nvar _index2 = require('./Sanitizer/index');\n\nObject.defineProperty(exports, 'CaseSensitiveSanitizer', {\n  enumerable: true,\n  get: function get() {\n    return _index2.CaseSensitiveSanitizer;\n  }\n});\nObject.defineProperty(exports, 'LowerCaseSanitizer', {\n  enumerable: true,\n  get: function get() {\n    return _index2.LowerCaseSanitizer;\n  }\n});\n\nvar _index3 = require('./SearchIndex/index');\n\nObject.defineProperty(exports, 'TfIdfSearchIndex', {\n  enumerable: true,\n  get: function get() {\n    return _index3.TfIdfSearchIndex;\n  }\n});\nObject.defineProperty(exports, 'UnorderedSearchIndex', {\n  enumerable: true,\n  get: function get() {\n    return _index3.UnorderedSearchIndex;\n  }\n});\n\nvar _index4 = require('./Tokenizer/index');\n\nObject.defineProperty(exports, 'SimpleTokenizer', {\n  enumerable: true,\n  get: function get() {\n    return _index4.SimpleTokenizer;\n  }\n});\nObject.defineProperty(exports, 'StemmingTokenizer', {\n  enumerable: true,\n  get: function get() {\n    return _index4.StemmingTokenizer;\n  }\n});\nObject.defineProperty(exports, 'StopWordsTokenizer', {\n  enumerable: true,\n  get: function get() {\n    return _index4.StopWordsTokenizer;\n  }\n});\n\nvar _Search = require('./Search');\n\nObject.defineProperty(exports, 'Search', {\n  enumerable: true,\n  get: function get() {\n    return _Search.Search;\n  }\n});\n\nvar _StopWordsMap = require('./StopWordsMap');\n\nObject.defineProperty(exports, 'StopWordsMap', {\n  enumerable: true,\n  get: function get() {\n    return _StopWordsMap.StopWordsMap;\n  }\n});\n\nvar _TokenHighlighter = require('./TokenHighlighter');\n\nObject.defineProperty(exports, 'TokenHighlighter', {\n  enumerable: true,\n  get: function get() {\n    return _TokenHighlighter.TokenHighlighter;\n  }\n});\n//# sourceMappingURL=index.js.map","import * as JSSearch from 'js-search';\nimport { IGraph, BaseGraph, TypedNode } from 'graphinius';\nimport { IndexConfig } from './interfaces';\n\ntype Types = {[key: string]: any[]};\ntype Indexes = {[key: string]: any};\n\n/**\n * Why does the import statement above work differently in TS / Bundled...\n */\nconst JsSearch = JSSearch.default || JSSearch;\n\n\nfunction buildIdxJSSearch(graph: IGraph, idxConfig: IndexConfig) : {} {\n  const types: Types = {};\n  Object.keys(idxConfig).forEach(k => types[k] = []);\n  const indexes: Indexes = {};\n  Object.keys(idxConfig).forEach(k => indexes[k] = null);\n\n  Object.values(graph.getNodes()).forEach( n => {\n    if ( BaseGraph.isTyped(n) === false ) {\n      throw Error(`Node Type not supported in this scenario...!`)\n    }\n    const type = (n as TypedNode).type.toLowerCase();\n    // console.log(type);\n\n    const idxObj = idxConfig[type];\n    if ( !idxObj ) {\n      return false;\n    }\n    let idxEntry = {id: n.id};\n    idxObj.fields.forEach(f => idxEntry[f] = n.f(f));\n\n    // console.log(idxEntry);\n\n    types[type].push(idxEntry);\n  });\n  // Object.keys(types).forEach(k => console.log(`${types[k].length} nodes of type ${k} registered.`));\n\n  Object.values(idxConfig).forEach(model => {\n    indexes[model.string] = new JsSearch.Search(model.id);\n    model.fields.forEach(f => indexes[model.string].addIndex(f));\n    indexes[model.string].addDocuments(types[model.string]);\n  });\n\n\n  /**\n   * In `jsdom` environment, we can use the first variant...\n   */\n  window['idx'] = indexes;\n  // if ( typeof window != null ) {\n  //   (<any>window)['idx'] = indexes;\n  // }\n  // console.log(indexes);\n  \n  return indexes;\n}\n\n\nexport {\n  buildIdxJSSearch\n}\n","import { IndexConfig, IndexEntryBody } from '../interfaces';\n\n/**\n * Just for declaring available Models\n *\n * @todo find more elegant solution (24/07/2019 -> too tired...)\n */\nexport enum shopifyModels {\n\ttag \t\t\t\t\t= 'tag',\n\tvendor \t\t\t\t= 'vendor',\n\tproduct\t\t\t\t= 'product',\n\tproduct_type \t= 'product_type'\n}\n\n\nconst shopifyIdxConfig: IndexConfig = {\n\ttag: {\n\t\tstring: 'tag',\n\t\tid: 'id',\n\t\tfields: ['name']\n\t},\n\tvendor: {\n\t\tstring: 'vendor',\n\t\tid: 'id',\n\t\tfields: ['label']\n\t},\n\tproduct_type: {\n\t\tstring: 'product_type',\n\t\tid: 'id',\n\t\tfields: ['label']\n\t},\n\tproduct: {\n\t\tstring: 'product',\n\t\tid: 'id',\n\t\tfields: ['label', 'body_sanitized']\n\t}\n};\n\nexport {\n\tshopifyIdxConfig\n}","import { AppConfig } from '../interfaces';\nimport { shopifyIdxConfig, shopifyModels } from './interfaces';\n\nconst testGraphDir = `../test-data/graphs`;\nconst graphs = [\n\t'hauslondon',\n\t'www.mvmtwatches',\n\t'skinnydiplondon'\n];\nconst graph = graphs[1];\nconst graphExt = `json`;\n\n\nconst shopifyConfig: AppConfig = {\n\tgraphName: graph,\n\tgraphFile: `${testGraphDir}/${graph}.com.${graphExt}`,\n\tsearchTerm: `caramel`,\n\tidxConfig: shopifyIdxConfig,\n\tmodels: shopifyModels,\n\tsearchModel: shopifyModels.product\n};\n\n\nexport {\n\tshopifyConfig\n}\n","import { IGraph, TypedGraph, ComputeGraph, BFS, DFS, PFS, Pagerank } from 'graphinius';\nimport { importGraph } from './common/importGraph';\nimport { TheExpanse } from './recommender/TheExpanse';\n\nimport { AppConfig } from './indexers/interfaces';\nimport { buildIdxJSSearch } from './indexers/buildJSSearch';\n\nimport { beerConfig } from './indexers/beer/appConfig';\nimport { jobsConfig } from './indexers/jobs/appConfig';\nimport { meetupConfig } from './indexers/meetup/appConfig';\nimport { northwindConfig } from './indexers/northwind/appConfig';\nimport { shopifyConfig } from './indexers/shopify/appConfig';\n\nimport {setSimFuncs as $setSim, scoreSimFuncs as $scoSim} from 'graphinius';\n\n/* HACKETY HACK */\nwindow.setSim = $setSim;\nwindow.scoSim = $scoSim;\n\n(() => {\n  [shopifyConfig].forEach(async (config) => {\n    // jobsConfig , northwindConfig , beerConfig , meetupConfig\n    const graph: TypedGraph = (await importGraph(config)) as TypedGraph;\n    window.ex = new TheExpanse(graph);\n    const indexes = createJSSearchIndex(graph, config);\n    const searchRes = executeSearch(indexes, config, graph);\n    testBDPFS(graph);\n    testPagerank(graph);\n    // await testTransitivityCc(graph);\n  });\n})();\n\nfunction testBDPFS(g: IGraph) {\n  let tic, toc;\n  [BFS, DFS, PFS].forEach((traversal) => {\n    tic = +new Date();\n    traversal(g, g.getRandomNode());\n    toc = +new Date();\n    console.log(`${traversal.name} on ${g.label} graph took ${toc - tic} ms.`);\n  });\n}\n\nfunction testPagerank(g: IGraph) {\n  const PR = new Pagerank(g, { normalize: true, epsilon: 1e-6 });\n  const tic = +new Date();\n  PR.computePR();\n  const toc = +new Date();\n  console.log(`Pagerank on ${g.label} graph took ${toc - tic} ms.`);\n}\n\nasync function testTransitivityCc(g) {\n  let tic, toc;\n  const cg = new ComputeGraph(g, window.tf);\n  // console.log(`TF backend is: ${window.tf.getBackend()}`); // -> undefined !?\n\n  tic = +new Date();\n  await cg.localCC(true);\n  toc = +new Date();\n  console.log(\n    `Clustering coefficient on ${g.label} graph took ${toc - tic} ms.`\n  );\n\n  tic = +new Date();\n  await cg.globalCC(true);\n  toc = +new Date();\n  console.log(`Transitivity on ${g.label} graph took ${toc - tic} ms.`);\n}\n\nfunction createJSSearchIndex(graph: IGraph, config: AppConfig) {\n  let tic = +new Date();\n  const indexes = buildIdxJSSearch(graph, config.idxConfig);\n  let toc = +new Date();\n  console.log(`Building Indexes in JS-SEARCH took ${toc - tic} ms.`);\n  return indexes;\n}\n\nfunction executeSearch(indexes, config: AppConfig, graph: TypedGraph) {\n  let tic = +new Date();\n  const searchRes = indexes[config.searchModel].search(config.searchTerm);\n  let toc = +new Date();\n  console.log(\n    `executing search for '${config.searchTerm}' in JS-SEARCH took ${\n      toc - tic\n    } ms.`\n  );\n\n  console.log(searchRes);\n\n  searchRes.forEach((res) => {\n    console.log(graph.getNodeById(res.id));\n  });\n\n  return searchRes;\n}\n"],"names":["$CB.execCallbacks","$E.BaseEdge","$BH.BinaryHeap","$BH.BinaryHeapMode","$PFS.DEFAULT_WEIGHT","$SU.clone","$SU.mergeObjects","$SU.mergeArrays","$N.BaseNode","logger","https.get","rng","bytesToUuid","v4","v1","DEFAULT_WEIGHT","$R.checkNodeEnvironment","fs.readFileSync","$R.retrieveRemoteFile","fs.writeFileSync","PRECISION","uuid.v4","_AllSubstringsIndexStrategy","_ExactWordIndexStrategy","_PrefixIndexStrategy","_CaseSensitiveSanitizer","_LowerCaseSanitizer","_getNestedFieldValue","_TfIdfSearchIndex","_UnorderedSearchIndex","_StopWordsMap","_SimpleTokenizer","_StemmingTokenizer","_StopWordsTokenizer","_index","_index3","_index2","_index4","_Search","_TokenHighlighter","JSSearch.default","$setSim","$scoSim"],"mappings":"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"}